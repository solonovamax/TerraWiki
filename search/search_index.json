{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.\\,\\_]+"},"docs":[{"location":"","text":"Welcome to the Terra Wiki \u00b6 What is Terra? \u00b6 Terra is an incredibly powerful free & open-source data-driven, platform-agnostic world generator. It provides the tools that allow you to create a world exactly to your specifications. Community & Support If you are unsure about anything or need clarification regarding Terra, you can contact us in our Discord server ! Terra is completely config-defined , meaning that it doesn't have any concept of what a forest, ocean, or even what a cave is. This means Terra is capable of producing worlds unlike the traditional overworld, such as new planets , alien worlds , aether-like dimensions , and much more! These concepts are all implemented through Terra's extensive configuration system, meaning that the main limiting factor is the configuration itself. Terra's config system is intuitive and relatively simple to learn, while also being the most powerful config system yet seen in a world generator. Whether you're a server owner looking to spice up your server with out-of-the-box custom terrain, a developer looking to tweak things to better fit your vision, or a creator looking to build completely new biomes or worlds from the ground up, Terra can meet your world generation needs! How do I get started? \u00b6 To get started with Terra, take a look at our Quick Start Guide . It will walk you through everything you need to get Terra working on your server, including installing the plugin and setting up a world with the generator. Translated Wikis Chinese A Chinese translation of the Wiki can be found here . Translation provided by qsefthuopq.","title":"Welcome"},{"location":"#welcome-to-the-terra-wiki","text":"","title":"Welcome to the Terra Wiki"},{"location":"#what-is-terra","text":"Terra is an incredibly powerful free & open-source data-driven, platform-agnostic world generator. It provides the tools that allow you to create a world exactly to your specifications. Community & Support If you are unsure about anything or need clarification regarding Terra, you can contact us in our Discord server ! Terra is completely config-defined , meaning that it doesn't have any concept of what a forest, ocean, or even what a cave is. This means Terra is capable of producing worlds unlike the traditional overworld, such as new planets , alien worlds , aether-like dimensions , and much more! These concepts are all implemented through Terra's extensive configuration system, meaning that the main limiting factor is the configuration itself. Terra's config system is intuitive and relatively simple to learn, while also being the most powerful config system yet seen in a world generator. Whether you're a server owner looking to spice up your server with out-of-the-box custom terrain, a developer looking to tweak things to better fit your vision, or a creator looking to build completely new biomes or worlds from the ground up, Terra can meet your world generation needs!","title":"What is Terra?"},{"location":"#how-do-i-get-started","text":"To get started with Terra, take a look at our Quick Start Guide . It will walk you through everything you need to get Terra working on your server, including installing the plugin and setting up a world with the generator. Translated Wikis Chinese A Chinese translation of the Wiki can be found here . Translation provided by qsefthuopq.","title":"How do I get started?"},{"location":"guides/Creating-a-Terra-World/","text":"This section is incomplete This guide is intended for the Bukkit version of Terra. Guides will be written for other platforms once they mature. How Bukkit handles Terra worlds \u00b6 In the Bukkit version of Terra, world management is delegated to Bukkit, meaning that generators are configured via Bukkit or a world management plugin, not in Terra. Bukkit uses the concept of generator ID s to dictate which worlds will use what generators, which is what this guide will be centered around configuring. The Generator ID Format \u00b6 For each Configuration Pack , Terra will assign a Bukkit generator ID with the format Terra:<PACK ID> . for example the default pack with the ID DEFAULT will have a generator ID of Terra:DEFAULT . Note The <PACK ID> portion of the generator ID is case sensitive meaning that your capitalization within the generator ID must match that of the pack ID! Setting up a Terra World \u00b6 Tip Terra comes pre-packaged with a default pack, which does not require a download/install. If this is your first time using Terra then we suggest using the default, which uses the ID DEFAULT . There are two main ways to manage worlds on a Bukkit server: using a world manager (which is a separate plugin that is designed to well.. manage worlds) - or - directly through Bukkit. Both methods have their own advantages which we will cover in each section. Setting a Generator Through directly through Bukkit \u00b6 If you are not using a world manager, then you will have to manually set up the generator for a world through the bukkit.yml configuration file. This can be found within your server root (the folder that all your server files are contained in). Something to note is that without a world manager, you cannot create new worlds! . The process goes as follows: Stop your server if it is already running. Open the bukkit.yml file with any text editor. Add the following lines to the end of the file, replacing the placeholders with the relevant information: worlds : <WORLD NAME> : # The name of the world folder. generator : <GENERATOR ID> # Specifying the generator Bukkit should use for the world. # For example the default pack would be Terra:DEFAULT Start your server. If you have already done this process before and wish to set up another world with a generator, you can simply add it to the worlds key like so: worlds: already_configured_world_name: generator: Terra:EXAMPLE_PACK_1 + <NEW WORLD NAME>: + generator: <NEW GENERATOR ID> Which will look like this once done: worlds : already_configured_world_name : generator : Terra:EXAMPLE_PACK_1 newly_configured_world_name : generator : Terra:EXAMPLE_PACK_2 Setting a Generator Through a World Manager \u00b6 Most world managers will have their own methods of setting / changing the generator for a world, however some may not support the use of custom generators. Please refer to either the documentation or support for your preferred manager if you're not sure whether custom generators are supported, or how to set up a world with said manager, before consulting the Terra discord. Since there are many different plugins with their own process we won't be covering all of them, however we do recommend using Multiverse Core if you are unsure which manager to use. BACKUP PLAN \u00b6 Sometimes world managers will fail to correctly set the generator for a world when loading things up, which can lead to potentially damaging issues with your worlds such as broken chunk borders. Because of this we recommend additionally configuring a world directly through Bukkit once you have set it up through a world manager, to serve as a fail-safe in the event that a world manager fails. Multiverse Core \u00b6 To create a Terra world using Multiverse Core, add the following argument to the end of the Multiverse Create Command : -g Terra:<PACK ID> . Here is an example command which will create a world with the name example_world , the NORMAL world environment, and a Terra generator using the pack with ID EXAMPLE : /mv create example_world NORMAL -g Terra:EXAMPLE","title":"Guides and Tutorials"},{"location":"guides/Creating-a-Terra-World/#how-bukkit-handles-terra-worlds","text":"In the Bukkit version of Terra, world management is delegated to Bukkit, meaning that generators are configured via Bukkit or a world management plugin, not in Terra. Bukkit uses the concept of generator ID s to dictate which worlds will use what generators, which is what this guide will be centered around configuring.","title":"How Bukkit handles Terra worlds"},{"location":"guides/Creating-a-Terra-World/#the-generator-id-format","text":"For each Configuration Pack , Terra will assign a Bukkit generator ID with the format Terra:<PACK ID> . for example the default pack with the ID DEFAULT will have a generator ID of Terra:DEFAULT . Note The <PACK ID> portion of the generator ID is case sensitive meaning that your capitalization within the generator ID must match that of the pack ID!","title":"The Generator ID Format"},{"location":"guides/Creating-a-Terra-World/#setting-up-a-terra-world","text":"Tip Terra comes pre-packaged with a default pack, which does not require a download/install. If this is your first time using Terra then we suggest using the default, which uses the ID DEFAULT . There are two main ways to manage worlds on a Bukkit server: using a world manager (which is a separate plugin that is designed to well.. manage worlds) - or - directly through Bukkit. Both methods have their own advantages which we will cover in each section.","title":"Setting up a Terra World"},{"location":"guides/Creating-a-Terra-World/#setting-a-generator-through-directly-through-bukkit","text":"If you are not using a world manager, then you will have to manually set up the generator for a world through the bukkit.yml configuration file. This can be found within your server root (the folder that all your server files are contained in). Something to note is that without a world manager, you cannot create new worlds! . The process goes as follows: Stop your server if it is already running. Open the bukkit.yml file with any text editor. Add the following lines to the end of the file, replacing the placeholders with the relevant information: worlds : <WORLD NAME> : # The name of the world folder. generator : <GENERATOR ID> # Specifying the generator Bukkit should use for the world. # For example the default pack would be Terra:DEFAULT Start your server. If you have already done this process before and wish to set up another world with a generator, you can simply add it to the worlds key like so: worlds: already_configured_world_name: generator: Terra:EXAMPLE_PACK_1 + <NEW WORLD NAME>: + generator: <NEW GENERATOR ID> Which will look like this once done: worlds : already_configured_world_name : generator : Terra:EXAMPLE_PACK_1 newly_configured_world_name : generator : Terra:EXAMPLE_PACK_2","title":"Setting a Generator Through directly through Bukkit"},{"location":"guides/Creating-a-Terra-World/#setting-a-generator-through-a-world-manager","text":"Most world managers will have their own methods of setting / changing the generator for a world, however some may not support the use of custom generators. Please refer to either the documentation or support for your preferred manager if you're not sure whether custom generators are supported, or how to set up a world with said manager, before consulting the Terra discord. Since there are many different plugins with their own process we won't be covering all of them, however we do recommend using Multiverse Core if you are unsure which manager to use.","title":"Setting a Generator Through a World Manager"},{"location":"guides/Creating-a-Terra-World/#multiverse-core","text":"To create a Terra world using Multiverse Core, add the following argument to the end of the Multiverse Create Command : -g Terra:<PACK ID> . Here is an example command which will create a world with the name example_world , the NORMAL world environment, and a Terra generator using the pack with ID EXAMPLE : /mv create example_world NORMAL -g Terra:EXAMPLE","title":"Multiverse Core"},{"location":"guides/config-packs/","text":"What exactly is a config pack? \u00b6 Config packs are a group of configuration files that define a Terra world generator. These configuration files are YAML based, and define all the necessary components to create a complete world generator with Terra. Users may install multiple config packs simultaneously, allowing the use of multiple Terra-based generators on the same server, with any number of worlds configured to use any of those generators. Where can I find config packs? \u00b6 You can find a list of community made Terra configuration packs on the Community Packs page. How do I install a pack? \u00b6 Config packs are installed similarly to resource packs, which is a fairly straight forward process: Note A pack can be contained inside either a folder, a .zip , or a .terra archive. Download your config pack, and place it in the directory plugins/Terra/packs/ , this is where all Terra config packs will be located, including the DEFAULT pack which is automatically installed with Terra. Once your pack is installed, load the pack on to the server by reloading Terra: If your server is not running , simply startup the server. If your server is already running : Production If you are installing the pack on a production environment , simply restart the server to load the new config pack. Test Environment Note Debug mode should only be enabled in a test environment! If you are installing the pack on a test environment and debug mode is enabled (covered in Creating a Pack ), you can run the command /terra reload to reload Terra. Warning Do not under any circumstances use the /reload command, or any third party plugin to reload your server. Restart the server instead! [Why?] If your pack has loaded correctly, then you should see this message in console after reloading Terra: [XX:XX:XX INFO]: [Terra] Loading config pack \"<PACK NAME>\" [XX:XX:XX INFO]: [Terra] <PACK NAME> <PACK VERSION> by <AUTHOR> loaded in XXXX.XXXXms. Troubleshooting Pack Installation If your pack failed to load, the console will display an error message outlining why the pack failed to load. Be sure to read through the error and double check if you have made a mistake anywhere. If you're unzipping a pack into a folder, ensure that pack.yml is contained within that folder, and not nested inside another folder like so: Correct <PACK NAME>/pack.yml Incorrect <FOLDER>/<PACK NAME>/pack.yml If you are unable to install the pack, and have attempted to fix any issues, please feel free to shoot us a message on our Discord server and provide any relevant error logs! How can I make my own pack? \u00b6 If you wish to work on making your own config pack, take a look at our Creating a Pack guide which outlines everything you need to know to get started creating your own customized Terra worlds.","title":"Config Packs"},{"location":"guides/config-packs/#what-exactly-is-a-config-pack","text":"Config packs are a group of configuration files that define a Terra world generator. These configuration files are YAML based, and define all the necessary components to create a complete world generator with Terra. Users may install multiple config packs simultaneously, allowing the use of multiple Terra-based generators on the same server, with any number of worlds configured to use any of those generators.","title":"What exactly is a config pack?"},{"location":"guides/config-packs/#where-can-i-find-config-packs","text":"You can find a list of community made Terra configuration packs on the Community Packs page.","title":"Where can I find config packs?"},{"location":"guides/config-packs/#how-do-i-install-a-pack","text":"Config packs are installed similarly to resource packs, which is a fairly straight forward process: Note A pack can be contained inside either a folder, a .zip , or a .terra archive. Download your config pack, and place it in the directory plugins/Terra/packs/ , this is where all Terra config packs will be located, including the DEFAULT pack which is automatically installed with Terra. Once your pack is installed, load the pack on to the server by reloading Terra: If your server is not running , simply startup the server. If your server is already running : Production If you are installing the pack on a production environment , simply restart the server to load the new config pack. Test Environment Note Debug mode should only be enabled in a test environment! If you are installing the pack on a test environment and debug mode is enabled (covered in Creating a Pack ), you can run the command /terra reload to reload Terra. Warning Do not under any circumstances use the /reload command, or any third party plugin to reload your server. Restart the server instead! [Why?] If your pack has loaded correctly, then you should see this message in console after reloading Terra: [XX:XX:XX INFO]: [Terra] Loading config pack \"<PACK NAME>\" [XX:XX:XX INFO]: [Terra] <PACK NAME> <PACK VERSION> by <AUTHOR> loaded in XXXX.XXXXms. Troubleshooting Pack Installation If your pack failed to load, the console will display an error message outlining why the pack failed to load. Be sure to read through the error and double check if you have made a mistake anywhere. If you're unzipping a pack into a folder, ensure that pack.yml is contained within that folder, and not nested inside another folder like so: Correct <PACK NAME>/pack.yml Incorrect <FOLDER>/<PACK NAME>/pack.yml If you are unable to install the pack, and have attempted to fix any issues, please feel free to shoot us a message on our Discord server and provide any relevant error logs!","title":"How do I install a pack?"},{"location":"guides/config-packs/#how-can-i-make-my-own-pack","text":"If you wish to work on making your own config pack, take a look at our Creating a Pack guide which outlines everything you need to know to get started creating your own customized Terra worlds.","title":"How can I make my own pack?"},{"location":"guides/issue-template/","text":"What this page is for \u00b6 This wiki page has been created to help you choose which issue template you want to use, if you are unsure of which one to choose. Choosing a template \u00b6 There are three basic templates to choose from, so it's pretty simple. Bug Report Feature Request Other The following sections describe each one: Bug Report If your issue is about unintentional things that occur with the program (eg. an error, etc.) then this is the right template. Choose this template if your issue has to do with one of the following: A glitch An error Something that broke Don't use this template if you fall into one of the following: It's not a glitch in the program and is instead something you can't do because of some limitation. (Open a Feature Request instead.) It has something to do with the repository itself. (Open an issue with the Other template instead.) Feature Request Use this template for anything regarding new features you would like to be added. Here are situations in which you should use this template: You want a new feature to be added You want to expand an existing feature You want to suggest an alternative to an existing feature Don't use this template if you fit one of the following: There is an error which occurs in the program. (Use a Bug Report instead.) You have a question about something Terra can do. (Use the \"Other\" template instead, or join our discord .) Other Use this if your issue doesn't neatly fit into any of the other categories. This is good for questions you may have, etc. (Note: If you have a simple question, please join the discord instead.)","title":"Choosing an issue template"},{"location":"guides/issue-template/#what-this-page-is-for","text":"This wiki page has been created to help you choose which issue template you want to use, if you are unsure of which one to choose.","title":"What this page is for"},{"location":"guides/issue-template/#choosing-a-template","text":"There are three basic templates to choose from, so it's pretty simple. Bug Report Feature Request Other The following sections describe each one: Bug Report If your issue is about unintentional things that occur with the program (eg. an error, etc.) then this is the right template. Choose this template if your issue has to do with one of the following: A glitch An error Something that broke Don't use this template if you fall into one of the following: It's not a glitch in the program and is instead something you can't do because of some limitation. (Open a Feature Request instead.) It has something to do with the repository itself. (Open an issue with the Other template instead.) Feature Request Use this template for anything regarding new features you would like to be added. Here are situations in which you should use this template: You want a new feature to be added You want to expand an existing feature You want to suggest an alternative to an existing feature Don't use this template if you fit one of the following: There is an error which occurs in the program. (Use a Bug Report instead.) You have a question about something Terra can do. (Use the \"Other\" template instead, or join our discord .) Other Use this if your issue doesn't neatly fit into any of the other categories. This is good for questions you may have, etc. (Note: If you have a simple question, please join the discord instead.)","title":"Choosing a template"},{"location":"guides/config/Block-Palettes/","text":"Block Palettes define a vertical slice of the world. They are lists of blocks, from which Terra picks based on the depth at a location. They are located in the palettes/ directory within a config pack. Palettes define the blocks used to generate the world, and they are configured on a per-Biome basis. Biomes contain a list of Palettes, based on Y levels, allowing the user to control which blocks generate at relative depths, and absolute depths. Relative depth \u00b6 Relative depth describes \"distance below the surface.\" For example, a Palette can specify that 3 blocks below the surface of the world, Stone should generate. Absolute depth \u00b6 Absolute depth is a Y-level. For example, a Biome can specify that at Y levels 0-96, a palette called GRASSY is to be used. Randomness \u00b6 Palettes offer two types of randomness to use for block selection. * Random - A pseudorandom number generator. This will produce random scattering of blocks. The seed is configurable. * Simplex - A simplex generator, redistributed to a continuous distribution. This will produce blob-like patches of blocks. The frequency and seed are configurable.","title":"Configuration"},{"location":"guides/config/Block-Palettes/#relative-depth","text":"Relative depth describes \"distance below the surface.\" For example, a Palette can specify that 3 blocks below the surface of the world, Stone should generate.","title":"Relative depth"},{"location":"guides/config/Block-Palettes/#absolute-depth","text":"Absolute depth is a Y-level. For example, a Biome can specify that at Y levels 0-96, a palette called GRASSY is to be used.","title":"Absolute depth"},{"location":"guides/config/Block-Palettes/#randomness","text":"Palettes offer two types of randomness to use for block selection. * Random - A pseudorandom number generator. This will produce random scattering of blocks. The seed is configurable. * Simplex - A simplex generator, redistributed to a continuous distribution. This will produce blob-like patches of blocks. The frequency and seed are configurable.","title":"Randomness"},{"location":"guides/config/Configuring-Your-Pack/","text":"CONTENTS \u00b6 Anatomy of a Pack Pack Structure Sub-folders Adjusting the Generator Reloading edits This section overviews the many options available to adjust world generation in your new config. In this section, we will go through the typical workflow involved in making changes to a pack, and cover some basic changes to the world generation. If you aren't sure where to get started with creating a pack, check out Creating a Pack . Anatomy of a Pack \u00b6 Terra configuration packs can be divided into sub-folders each containing different configuration file types. Every pack has a unique ID, used for setting up world generators and loading everything correctly. If you have already read through Creating a Pack , then you should already know how to set up the ID for a pack. Pack Structure \u00b6 Here is what to expect when looking inside a Terra config pack. You can expand the following sections to read descriptions of each: :page_facing_up: pack.yml >[Pack Manifest](./pack.yml-Options) documentation If you followed [Creating a Pack](./Creating-a-Pack), then you should already be familiar with pack.yml. The pack manifest controls broad scale things like *how biomes are arranged*, and defines things integral to a pack such as the *author, version and pack name*. --- :file_folder: biomes > The `biomes` folder contains user-defined [Biome Configurations](./Biome-Configuration). Aside from pack.yml, you will probably be configuring the bulk of your work inside this folder, as it contains everything that makes biomes unique. Biomes generally take many assets defined in other folders (or even other biomes!) and combines them together to define a singular unique biome. Many biomes can share aspects such as the blocks that make up the landscape, what trees within the biome, and how ores spawn etc. For a full list of biome parameters you can check out the [Biome Configuration](./Biome-Configuration) documentation. --- :file_folder: carving > The `carving` folder contains user-defined [Carver Configurations](./Carver-Configuration). Carver configurations define the behaviour of basic caves in Terra. Biomes can pick and choose which carvers they take from this folder to use when generating. If you want to change how caves look, then is the folder to go to. --- :file_folder: flora > The `flora` folder contains user-defined [Flora Configurations](./Flora-Configuration). Flora configurations define aspects like grass and flowers that will be used within biome configurations, but can also be generalized to other aspects of generation such as sugarcane, lily-pads, water springs etc. Flora is generally configured to be a block or stack of blocks that only spawns under certain conditions. For example sugarcane would only generate on grass and sand that is adjacent to water, and can only replace air blocks. You can think of flora like a *post-processor*. If you want to configure your own flora, you would do it in this folder. Alternatively, Terra also provides various [preset flora configs](./Included-Flora) included within the plugin. --- :file_folder: ores > The `ore` folder contains user-defined [Ore Configurations](./Ore-Configuration). Ore configurations determine how various individual deposits of blocks behave. Aspects like what block deposits are made of, and how large deposits are can be controlled here. Note that ore configurations pertain to how singular deposits behave, meaning that aspects like *where* and *how frequent* deposits are not handled in this folder (Those factors are defined within biomes). Another thing to note is that aspects like dirt and granite pockets are also defined here, meaning that ore configurations are not specific to just ores. --- :file_folder: palettes >The `palettes` folder contains user-defined [Palette Configurations](./Palette-Configuration). --- :file_folder: structures The `structure` folder contains several Terra defined sub-directories as follows: * :file_folder:`trees` >[Tree Configuration](./Tree-Configuration) documentation * :file_folder:`structures` >[Structure Configuration](./Structure-Configuration) documentation * :file_folder:`loot` Loot tables * :file_folder:`data` >[Terrascript](./TerraScript) documentation --- Sub-folders \u00b6 Just about every configuration file within each pack sub-directory can be further nested in user-defined folders for organization. This can be very useful for pack development as it will make files much easier to locate and edit, and is a good practice to do to make things neater. For example, here is what an organized biome folder structure might look like: # Terra defined folders pack \u2514 biomes # User defined folders \u251c land \u2502 \u251c hot \u2502 \u2502 \u2514 desert.yml \u2502 \u251c temperate \u2502 \u2502 \u251c forest.yml \u2502 \u2502 \u2514 plains.yml \u2502 \u2514 cold \u2502 \u2514 tundra.yml \u2514 water \u251c ocean.yml \u2514 river.yml Adjusting the Generator \u00b6 ! This section is incomplete ! Terra has a vast amount of options for configuring world generation from the ground up. We don't expect you to be able to pick up every little aspect as there is a lot to take in, but you will have to put in some work grasping a handful of important concepts, if you're looking to develop a pack. These topics include: Noise Objects Weighted Pools Biome Pipeline TerraScript Reloading edits \u00b6 When adjusting your configuration, you might think that you will need to restart your whole server for any changes to take effect. This is not the case with Terra; you can simply reload your configurations live while the server is running. If your server is in debug mode (which is covered in Creating a Pack ), simply run /te reload to reload all configurations. NOTE \u00b6 You will still need to generate new chunks after reloading to preview any changes!","title":"Configuring Your Pack"},{"location":"guides/config/Configuring-Your-Pack/#anatomy-of-a-pack","text":"Terra configuration packs can be divided into sub-folders each containing different configuration file types. Every pack has a unique ID, used for setting up world generators and loading everything correctly. If you have already read through Creating a Pack , then you should already know how to set up the ID for a pack.","title":"Anatomy of a Pack"},{"location":"guides/config/Configuring-Your-Pack/#pack-structure","text":"Here is what to expect when looking inside a Terra config pack. You can expand the following sections to read descriptions of each: :page_facing_up: pack.yml >[Pack Manifest](./pack.yml-Options) documentation If you followed [Creating a Pack](./Creating-a-Pack), then you should already be familiar with pack.yml. The pack manifest controls broad scale things like *how biomes are arranged*, and defines things integral to a pack such as the *author, version and pack name*. --- :file_folder: biomes > The `biomes` folder contains user-defined [Biome Configurations](./Biome-Configuration). Aside from pack.yml, you will probably be configuring the bulk of your work inside this folder, as it contains everything that makes biomes unique. Biomes generally take many assets defined in other folders (or even other biomes!) and combines them together to define a singular unique biome. Many biomes can share aspects such as the blocks that make up the landscape, what trees within the biome, and how ores spawn etc. For a full list of biome parameters you can check out the [Biome Configuration](./Biome-Configuration) documentation. --- :file_folder: carving > The `carving` folder contains user-defined [Carver Configurations](./Carver-Configuration). Carver configurations define the behaviour of basic caves in Terra. Biomes can pick and choose which carvers they take from this folder to use when generating. If you want to change how caves look, then is the folder to go to. --- :file_folder: flora > The `flora` folder contains user-defined [Flora Configurations](./Flora-Configuration). Flora configurations define aspects like grass and flowers that will be used within biome configurations, but can also be generalized to other aspects of generation such as sugarcane, lily-pads, water springs etc. Flora is generally configured to be a block or stack of blocks that only spawns under certain conditions. For example sugarcane would only generate on grass and sand that is adjacent to water, and can only replace air blocks. You can think of flora like a *post-processor*. If you want to configure your own flora, you would do it in this folder. Alternatively, Terra also provides various [preset flora configs](./Included-Flora) included within the plugin. --- :file_folder: ores > The `ore` folder contains user-defined [Ore Configurations](./Ore-Configuration). Ore configurations determine how various individual deposits of blocks behave. Aspects like what block deposits are made of, and how large deposits are can be controlled here. Note that ore configurations pertain to how singular deposits behave, meaning that aspects like *where* and *how frequent* deposits are not handled in this folder (Those factors are defined within biomes). Another thing to note is that aspects like dirt and granite pockets are also defined here, meaning that ore configurations are not specific to just ores. --- :file_folder: palettes >The `palettes` folder contains user-defined [Palette Configurations](./Palette-Configuration). --- :file_folder: structures The `structure` folder contains several Terra defined sub-directories as follows: * :file_folder:`trees` >[Tree Configuration](./Tree-Configuration) documentation * :file_folder:`structures` >[Structure Configuration](./Structure-Configuration) documentation * :file_folder:`loot` Loot tables * :file_folder:`data` >[Terrascript](./TerraScript) documentation ---","title":"Pack Structure"},{"location":"guides/config/Configuring-Your-Pack/#sub-folders","text":"Just about every configuration file within each pack sub-directory can be further nested in user-defined folders for organization. This can be very useful for pack development as it will make files much easier to locate and edit, and is a good practice to do to make things neater. For example, here is what an organized biome folder structure might look like: # Terra defined folders pack \u2514 biomes # User defined folders \u251c land \u2502 \u251c hot \u2502 \u2502 \u2514 desert.yml \u2502 \u251c temperate \u2502 \u2502 \u251c forest.yml \u2502 \u2502 \u2514 plains.yml \u2502 \u2514 cold \u2502 \u2514 tundra.yml \u2514 water \u251c ocean.yml \u2514 river.yml","title":"Sub-folders"},{"location":"guides/config/Configuring-Your-Pack/#adjusting-the-generator","text":"! This section is incomplete ! Terra has a vast amount of options for configuring world generation from the ground up. We don't expect you to be able to pick up every little aspect as there is a lot to take in, but you will have to put in some work grasping a handful of important concepts, if you're looking to develop a pack. These topics include: Noise Objects Weighted Pools Biome Pipeline TerraScript","title":"Adjusting the Generator"},{"location":"guides/config/Configuring-Your-Pack/#reloading-edits","text":"When adjusting your configuration, you might think that you will need to restart your whole server for any changes to take effect. This is not the case with Terra; you can simply reload your configurations live while the server is running. If your server is in debug mode (which is covered in Creating a Pack ), simply run /te reload to reload all configurations.","title":"Reloading edits"},{"location":"guides/config/Creating-a-Pack/","text":"Preface \u00b6 This guide will outline the process of creating a new Terra configuration pack. If you haven't already, check out Config Packs for more information on config packs before continuing. While Terra has a very intuitive config system, this does not mean creating a decent config is an easy task! Procedural world generation contains a lot of moving parts and you will need to put in effort towards understanding Terra's components if you want to create beautiful worlds. Creating a pack can be a complicated process, so if you get stuck at any stage, or need some clarification, be sure to ask for help if you need it! We'll be happy to help you in our Discord server . Preparation \u00b6 This section goes over the basic setup for a Terra configuration pack, including duplicating an existing pack to serve as a base, and setting up a workspace for working with packs. Before you begin, ensure you have a suitable test server with Terra installed. ! Do not follow the following steps on any live production environment ! If you haven't already, start up your test server and ensure the plugin has been set up correctly, otherwise check out the Quick Start Guide before continuing. Open plugins/Terra/config.yml in a text editor, and set debug to true like so: debug : true Duplicate an existing pack to serve as a template: Navigate to the packs directory located at plugins/Terra/packs Extract the contents of the default.zip directory into a new folder. TEMPLATE PACK \u00b6 Alternatively you can use the template configuration pack provided by Astrash, which provides minimal configurations and annotated explanations. The GitHub repository can be found here . Rename this new folder whatever want, this tutorial will call the new config folder example . Open the new pack directory in a text editor of your choice. EDITOR TIP \u00b6 We highly recommend using a text editor or IDE such as VSCode or InteliJ, which provides support for YAML syntax highlighting and file browsing support, as it will make things much more streamlined and easy for you, the config editor! Set up an ID for your new pack: In your text editor, open up pack.yml , found in the root directory of the new config pack. Within pack.yml , Change the id to the ID you wish to assign your config, as well as the author to your username like so: id : EXAMPLE_ID # Replace 'EXAMPLE_ID' with your desired pack ID author : dfsek # Replace 'dfsek' with your username Configure your test server's world to use the new config as a generator: Open bukkit.yml (Found in the root of the server). Assign your new generator to the default world by adding the following lines to the end of the file : worlds : <LEVEL NAME> : # The name of this can be found in the 'server.properties' under # the 'level-name' key. By default, level-name is set to 'world'. generator : Terra:EXAMPLE # Replace 'EXAMPLE' with the ID of your config. Stop your test server, delete the world folder, and start your server again. Your test server will now be using your new config pack! Let's Recap \u00b6 You now have a copy of the default / template config, called EXAMPLE . The pack is running on your test server, and the default world is assigned to the generate using the pack. You have a workspace in a suitable text-editor set up to work on this new config. Onwards! \u00b6 Once you have successfully set up your own Terra config pack, you may continue to the Configuring Your Pack page, where we will cover pack configuration.","title":"Creating a Pack"},{"location":"guides/config/Creating-a-Pack/#preface","text":"This guide will outline the process of creating a new Terra configuration pack. If you haven't already, check out Config Packs for more information on config packs before continuing. While Terra has a very intuitive config system, this does not mean creating a decent config is an easy task! Procedural world generation contains a lot of moving parts and you will need to put in effort towards understanding Terra's components if you want to create beautiful worlds. Creating a pack can be a complicated process, so if you get stuck at any stage, or need some clarification, be sure to ask for help if you need it! We'll be happy to help you in our Discord server .","title":"Preface"},{"location":"guides/config/Creating-a-Pack/#preparation","text":"This section goes over the basic setup for a Terra configuration pack, including duplicating an existing pack to serve as a base, and setting up a workspace for working with packs. Before you begin, ensure you have a suitable test server with Terra installed. ! Do not follow the following steps on any live production environment ! If you haven't already, start up your test server and ensure the plugin has been set up correctly, otherwise check out the Quick Start Guide before continuing. Open plugins/Terra/config.yml in a text editor, and set debug to true like so: debug : true Duplicate an existing pack to serve as a template: Navigate to the packs directory located at plugins/Terra/packs Extract the contents of the default.zip directory into a new folder.","title":"Preparation"},{"location":"guides/config/Creating-a-Pack/#lets-recap","text":"You now have a copy of the default / template config, called EXAMPLE . The pack is running on your test server, and the default world is assigned to the generate using the pack. You have a workspace in a suitable text-editor set up to work on this new config.","title":"Let's Recap"},{"location":"guides/config/Creating-a-Pack/#onwards","text":"Once you have successfully set up your own Terra config pack, you may continue to the Configuring Your Pack page, where we will cover pack configuration.","title":"Onwards!"},{"location":"guides/config/Custom-Blocks/","text":"This page discusses how to generate custom blocks in your world using outside custom item plugins such as MMOItems and CustomItems (these two just for sake of example, there are likely other custom item plugins out there worth checking out). For information on configuring ore generation with Terra, see Ore Configuration . This tutorial is for Bukkit only. On other platforms, simply use the namespaced ID of the block you want, the same way as you would any Minecraft block. Custom Blocks \u00b6 It's important to understand that custom item plugins do not actually add new blocks to Minecraft, but instead replace existing blocks. The blocks of choice are usually Brown and Red Mushroom Blocks due to their many block states. As of Minecraft 1.14, the way in which Mushroom Blocks are handled has changed from numeric IDs to directional facings. As a result, this guide will be covering Minecraft 1.14 (and above) versions only . Knowing custom blocks are mushroom blocks, we will be using this to figure out how to have custom ore generate in your world with a unique texture (thanks to your custom item plugin, note that Terra by itself does not offer such a feature ). Getting Block Facings \u00b6 When you create a custom block (using a custom item plugin!) and place it on the ground, if you did everything correctly, you will see a custom block instead of a mushroom block. So, how do we get this block to generate in your world naturally? After creating a custom block, place the block on the ground and press F3 to bring up Minecraft's debug screen. The information we need is the block state information on the right: This information will only show if you're looking at the custom block. The information highlighted is the most important, but directly above it is whether it's a red or brown mushroom block. In this example, it's a red_mushroom_block . You'll want to know this information, too. The combination of whether it's a red or brown mushroom block and the facings in which they are true or false will be unique to each type of custom block you have and will be key in determining what spawns where and how in your Ore Configuration . Generating Custom Blocks \u00b6 Navigate to your ores folder and create a new .YML file. In my example, I want my custom block to generate with a similar size to diamonds, so I'll take the provided minerals/diamond.yml 's setup as an example: material : \"minecraft:red_mushroom_block[down=false,south=false]\" size : min : 8 max : 8 extends : MINERAL id : \"SAPPHIRE_ORE\" The big takeaway here is the material: field. As shown in our example, our block was a red_mushroom_block (and not a brown_mushroom_block), so we set that as the material. However, in order to grab the facings, we must review which facings were false . By default, all facings are true, so for every facing that is true, you don't need to include it anywhere. You only need to include what is shown as false. In our case, both down and south were false , so we include that with square brackets right next to the material (with no space !). You use a comma with no space to separate each facing that is false. Feel free to copy and paste the above example and adjust the values as necessary for your own custom block. the id field can be anything we wish. In this example, I opted for SAPPHIRE_ORE . This is what you'll use for Terra to generate it into your world.","title":"Custom Blocks"},{"location":"guides/config/Custom-Blocks/#custom-blocks","text":"It's important to understand that custom item plugins do not actually add new blocks to Minecraft, but instead replace existing blocks. The blocks of choice are usually Brown and Red Mushroom Blocks due to their many block states. As of Minecraft 1.14, the way in which Mushroom Blocks are handled has changed from numeric IDs to directional facings. As a result, this guide will be covering Minecraft 1.14 (and above) versions only . Knowing custom blocks are mushroom blocks, we will be using this to figure out how to have custom ore generate in your world with a unique texture (thanks to your custom item plugin, note that Terra by itself does not offer such a feature ).","title":"Custom Blocks"},{"location":"guides/config/Custom-Blocks/#getting-block-facings","text":"When you create a custom block (using a custom item plugin!) and place it on the ground, if you did everything correctly, you will see a custom block instead of a mushroom block. So, how do we get this block to generate in your world naturally? After creating a custom block, place the block on the ground and press F3 to bring up Minecraft's debug screen. The information we need is the block state information on the right: This information will only show if you're looking at the custom block. The information highlighted is the most important, but directly above it is whether it's a red or brown mushroom block. In this example, it's a red_mushroom_block . You'll want to know this information, too. The combination of whether it's a red or brown mushroom block and the facings in which they are true or false will be unique to each type of custom block you have and will be key in determining what spawns where and how in your Ore Configuration .","title":"Getting Block Facings"},{"location":"guides/config/Custom-Blocks/#generating-custom-blocks","text":"Navigate to your ores folder and create a new .YML file. In my example, I want my custom block to generate with a similar size to diamonds, so I'll take the provided minerals/diamond.yml 's setup as an example: material : \"minecraft:red_mushroom_block[down=false,south=false]\" size : min : 8 max : 8 extends : MINERAL id : \"SAPPHIRE_ORE\" The big takeaway here is the material: field. As shown in our example, our block was a red_mushroom_block (and not a brown_mushroom_block), so we set that as the material. However, in order to grab the facings, we must review which facings were false . By default, all facings are true, so for every facing that is true, you don't need to include it anywhere. You only need to include what is shown as false. In our case, both down and south were false , so we include that with square brackets right next to the material (with no space !). You use a comma with no space to separate each facing that is false. Feel free to copy and paste the above example and adjust the values as necessary for your own custom block. the id field can be anything we wish. In this example, I opted for SAPPHIRE_ORE . This is what you'll use for Terra to generate it into your world.","title":"Generating Custom Blocks"},{"location":"guides/config/List-o%27-Noise-Equations/","text":"List o' Noise Equations \u00b6 This page contains a bunch of cool noise equations you may want to use in your world. These are simply examples to get started with, to make custom noise equations, see My First Noise Equation . All equations shown here are demonstrated with a minimal biome config, using a simple grassy palette and stone slant palette, with no flora or trees. Standard biomes \u00b6 Plains-like equation \u00b6 This equation generates rolling hills for a plains-style biome; noise-equation : \"((-((y / base)^2)) + 1) + |(noise2(x, z) / 3) + 0.1|\" Image Plains-like with islands \u00b6 The plains equation, but with a second layer on top of it that generates floating islands. noise-equation : \"if(max(y-96, 0), -(if(max(y-150, 0), |y-150|, |y-150|/16)) - 0.25 + (noise2(x*3, z*3)*3), ((-((y / base)^2)) + 1) + |(noise2(x, z) / 3) + 0.1|)\" Image Forest equation \u00b6 Similar to the plains equation, but with more hilly terrain with some areas going below sea level (in this case, I set sea level to 62.) noise-equation : \"((-((y / base)^2)) + 1) + ((noise2(x, z)+0.5) / 2)\" Image Crag equation \u00b6 Equation that produces 6 levels of terraces, each level using a different noise function. noise-equation : \"((-((y / 76)^2)) + 1) + |(noise2(x/1.5, z/1.5)+0.5)|/2.5\" elevation : equation : \"min(floor(((max(noise2(x/1.5, z/1.5)+0.5, 0)))*8), 6)*5 + if(max(noise2(x/1.5, z/1.5)+0.375, 0), (noise2(3*x+(min(floor(((max(noise2(x/1.5, z/1.5)+0.5, 0)))*8), 6)+1)*1000,3*z))*7, 0)\" interpolation : true Image","title":"List o' Noise Equations"},{"location":"guides/config/List-o%27-Noise-Equations/#list-o-noise-equations","text":"This page contains a bunch of cool noise equations you may want to use in your world. These are simply examples to get started with, to make custom noise equations, see My First Noise Equation . All equations shown here are demonstrated with a minimal biome config, using a simple grassy palette and stone slant palette, with no flora or trees.","title":"List o' Noise Equations"},{"location":"guides/config/List-o%27-Noise-Equations/#standard-biomes","text":"","title":"Standard biomes"},{"location":"guides/config/List-o%27-Noise-Equations/#plains-like-equation","text":"This equation generates rolling hills for a plains-style biome; noise-equation : \"((-((y / base)^2)) + 1) + |(noise2(x, z) / 3) + 0.1|\" Image","title":"Plains-like equation"},{"location":"guides/config/List-o%27-Noise-Equations/#plains-like-with-islands","text":"The plains equation, but with a second layer on top of it that generates floating islands. noise-equation : \"if(max(y-96, 0), -(if(max(y-150, 0), |y-150|, |y-150|/16)) - 0.25 + (noise2(x*3, z*3)*3), ((-((y / base)^2)) + 1) + |(noise2(x, z) / 3) + 0.1|)\" Image","title":"Plains-like with islands"},{"location":"guides/config/List-o%27-Noise-Equations/#forest-equation","text":"Similar to the plains equation, but with more hilly terrain with some areas going below sea level (in this case, I set sea level to 62.) noise-equation : \"((-((y / base)^2)) + 1) + ((noise2(x, z)+0.5) / 2)\" Image","title":"Forest equation"},{"location":"guides/config/List-o%27-Noise-Equations/#crag-equation","text":"Equation that produces 6 levels of terraces, each level using a different noise function. noise-equation : \"((-((y / 76)^2)) + 1) + |(noise2(x/1.5, z/1.5)+0.5)|/2.5\" elevation : equation : \"min(floor(((max(noise2(x/1.5, z/1.5)+0.5, 0)))*8), 6)*5 + if(max(noise2(x/1.5, z/1.5)+0.375, 0), (noise2(3*x+(min(floor(((max(noise2(x/1.5, z/1.5)+0.5, 0)))*8), 6)+1)*1000,3*z))*7, 0)\" interpolation : true Image","title":"Crag equation"},{"location":"guides/config/Multi-layered-Noise-Equations/","text":"As we have demonstrated in Noise Equations , you can determine how your biome looks like with a function. There is however also the possibility to define multiple functions that are used when certain conditions are met, such as for certain heights. A simple condition \u00b6 There is a simple example in the [[nether delta biome config| https://github.com/PolyhedralDev/TerraDefaultConfig/blob/final-config/packs/nether/biomes/delta.yml#L1 ]]: noise-equation: \"if(y, abs(y-64)/128 + noise3(x*1.5, y*2, z*1.5)*3, 1)\" This example has a so-called \"ternary if\". It follow the principle if A is not 0 then do B, otherwise do C . It's written in the biome config as if(A, B, C) . If we translate the noise equation accordingly, we get this here: if y is not 0 then use the function abs(y-64)/128 + noise3(x*1.5, y*2, z*1.5)*3 , otherwise just output 1 or reversed: if y = 0 output 1 , otherwise abs(y-64)/128 + noise3(x*1.5, y*2, z*1.5)*3 As we read before, the only question that this function tries to answer is if we have solid blocks or air. Positive outputs return blocks, (e.g. a 1), negative outputs return air. So in this case we will have a solid layer of blocks at height zero and something else everywhere above that, depending on that function given. This is a relatively simple example since it includes only a fixed solid layer (good for bedrock for example) and another function. Going all in \u00b6 We can get much more complex however by providing multiple functions per height. This is demonstrated in the [[plains-sky biome| https://github.com/PolyhedralDev/Terra/blob/92cdcba9f37154e581225100a3cba283560e666e/src/main/resources/default-config/biomes/plains_sky.yml#L4 ]]: noise-equation: \"if(max(y-96, 0), -(if(max(y-150, 0), |y-150|, |y-150|/16)) - 0.25 + (noise2(x*3, z*3)*3), ((-((y / 63)^2)) + 1) + |(noise2(x, z) / 3) + 0.1|)\" which returns this nice landscape with floating islands above: This one does not only add 2 functions as output but also a function to check which one of the two to pick. Let's take this one apart: if max(y-96, 0) is not 0 then do -(if(max(y-150, 0), |y-150|, |y-150|/16)) - 0.25 + (noise2(x*3, z*3)*3) else do ((-((y / 63)^2)) + 1) + |(noise2(x, z) / 3) + 0.1|) That looks complicated. Let's go step by step: The condition is max(y-96, 0) . Let's put that into a graphing calculator and see what it gives us back: As we can see, every value is zero at and below 96 and positive above it (97 and more). So the condition will do the second function below 97 height and the first at 97 and above. The second function is a function that just makes the land below the islands. Let's focus on the first one since it does not only define a surface at a certain height, but on top of it how the underside of the islands looks like. This is achieved by even another, nested conditional function inside the second argument: -(if(max(y-150, 0), |y-150|, |y-150|/16)) - 0.25 + (noise2(x*3, z*3)*3) . So what this does is: -(condition) - 0.25 + (noise2(x*3, z*3)*3) and that condition is: if max(y-150, 0) is not 0 then do |y-150| else do |y-150|/16 once we include that output in the function above, we get the following: if max(y-150, 0) is not 0 then do -(|y-150|) - 0.25 + (noise2(x*3, z*3)*3) else do -(|y-150|/16) - 0.25 + (noise2(x*3, z*3)*3) What this essentially does is giving the floating islands will have a steep bottom (below 150) and a flat top (at and above 151). To sum up: \u00b6 It's only up to you how complex you get in defining layers in your world.","title":"Multi layered Noise Equations"},{"location":"guides/config/Multi-layered-Noise-Equations/#a-simple-condition","text":"There is a simple example in the [[nether delta biome config| https://github.com/PolyhedralDev/TerraDefaultConfig/blob/final-config/packs/nether/biomes/delta.yml#L1 ]]: noise-equation: \"if(y, abs(y-64)/128 + noise3(x*1.5, y*2, z*1.5)*3, 1)\" This example has a so-called \"ternary if\". It follow the principle if A is not 0 then do B, otherwise do C . It's written in the biome config as if(A, B, C) . If we translate the noise equation accordingly, we get this here: if y is not 0 then use the function abs(y-64)/128 + noise3(x*1.5, y*2, z*1.5)*3 , otherwise just output 1 or reversed: if y = 0 output 1 , otherwise abs(y-64)/128 + noise3(x*1.5, y*2, z*1.5)*3 As we read before, the only question that this function tries to answer is if we have solid blocks or air. Positive outputs return blocks, (e.g. a 1), negative outputs return air. So in this case we will have a solid layer of blocks at height zero and something else everywhere above that, depending on that function given. This is a relatively simple example since it includes only a fixed solid layer (good for bedrock for example) and another function.","title":"A simple condition"},{"location":"guides/config/Multi-layered-Noise-Equations/#going-all-in","text":"We can get much more complex however by providing multiple functions per height. This is demonstrated in the [[plains-sky biome| https://github.com/PolyhedralDev/Terra/blob/92cdcba9f37154e581225100a3cba283560e666e/src/main/resources/default-config/biomes/plains_sky.yml#L4 ]]: noise-equation: \"if(max(y-96, 0), -(if(max(y-150, 0), |y-150|, |y-150|/16)) - 0.25 + (noise2(x*3, z*3)*3), ((-((y / 63)^2)) + 1) + |(noise2(x, z) / 3) + 0.1|)\" which returns this nice landscape with floating islands above: This one does not only add 2 functions as output but also a function to check which one of the two to pick. Let's take this one apart: if max(y-96, 0) is not 0 then do -(if(max(y-150, 0), |y-150|, |y-150|/16)) - 0.25 + (noise2(x*3, z*3)*3) else do ((-((y / 63)^2)) + 1) + |(noise2(x, z) / 3) + 0.1|) That looks complicated. Let's go step by step: The condition is max(y-96, 0) . Let's put that into a graphing calculator and see what it gives us back: As we can see, every value is zero at and below 96 and positive above it (97 and more). So the condition will do the second function below 97 height and the first at 97 and above. The second function is a function that just makes the land below the islands. Let's focus on the first one since it does not only define a surface at a certain height, but on top of it how the underside of the islands looks like. This is achieved by even another, nested conditional function inside the second argument: -(if(max(y-150, 0), |y-150|, |y-150|/16)) - 0.25 + (noise2(x*3, z*3)*3) . So what this does is: -(condition) - 0.25 + (noise2(x*3, z*3)*3) and that condition is: if max(y-150, 0) is not 0 then do |y-150| else do |y-150|/16 once we include that output in the function above, we get the following: if max(y-150, 0) is not 0 then do -(|y-150|) - 0.25 + (noise2(x*3, z*3)*3) else do -(|y-150|/16) - 0.25 + (noise2(x*3, z*3)*3) What this essentially does is giving the floating islands will have a steep bottom (below 150) and a flat top (at and above 151).","title":"Going all in"},{"location":"guides/config/Multi-layered-Noise-Equations/#to-sum-up","text":"It's only up to you how complex you get in defining layers in your world.","title":"To sum up:"},{"location":"guides/config/My-First-Noise-Equation/","text":"Biome Noise Equation \u00b6 At the heart of Terra's terrain generation is the noise-equation key found in all biome configs. Here's an example: noise-equation : \"((-(y / 62)^2) + 1) + ((noise2(x, z)+0.5) / 3)\" This page is a tutorial, which will demonstrate how to create an equation to produce your desired type of terrain. Oh no, math! What does it mean? \u00b6 The principle behind the noise equation is very simple. The equation takes in 3 variables, x , y and z , and converts them into an output. When Terra is generating the chunk base (Base generation is the first phase of terrain generation, where the shape of the terrain is defined), the current coordinates are fed into this equation. If the result is positive, the location is solid. If the result is negative, the location is air. Example \u00b6 Let's start with a very simple noise equation: noise-equation : \"(-y/64)+1\" This is simply a linear equation, with no noise involved. The result this gives is incredibly boring, a perfectly flat world: Notice that ground level is at Y=64, since when a value lower than 64 is passed into the equation for Y, the result is positive, causing all blocks at Y=63 and lower to be solid. If you graph the equation, you can clearly see the relationship: This is boring. How can we make actual terrain? \u00b6 With noise, of course! Terra contains 2 custom functions you can include in your equations, noise2(x, z) and noise3(x, y, z) . These functions exist to, as their names suggest, provide noise to use in your terrain. They provide noise from a Simplex Octave generator, seeded with the world seed, with octaves and frequencies defined in Terra's world config. Below is an example of Simplex Noise. As you can see, the noise creates a gradient. This is useful in terrain generation, as it allows variation to be added to terrain. Let's start with a simple 2D Simplex height map! noise-equation : \"(-y/64)+1 + noise2(x, z)\" This equation adds the 2D Simplex noise fetched from the X and Z coordinates to the linear equation we defined previously. Now, our world looks like this: Hold on, what exactly is happening there? \u00b6 Basically, since we are adding the result of the Simplex Noise (Which ranges from -1.0 to 1.0 and follows a Gaussian Distribution ) to the original equation, we are \"offsetting\" the base height (Y=63) of the terrain by whatever the result of the Simplex operation is. This creates nice hills/mountains in our terrain, and grants us many configuration possibilities! Too hilly. How can we get flatter terrain? \u00b6 Divide the noise result by a number, of course! Here's a new equation, which divides the noise value by 2: noise-equation : \"(-y/64)+1 + noise2(x, z)/2\" And here's what the terrain looks like now: Improving the base equation \u00b6 I have found that for most cases, a linear base equation is not ideal. For a majority of my biomes, I use a quadratic equation as a base. Specifically, I use: noise-equation : \"-((y / 64)^2) + 1\" The above equation gives a similar result to the linear equation, except it \"drops off\" faster at higher Y-values. Here's the terrain generated from the equation: noise-equation : \"-((y / 64)^2) + 1 + noise2(x, z) / 2\" Add some flora and trees, and we now have a pretty nice Plains biome! noise-equation : \"-((y / 64)^2) + 1 + noise2(x, z) / 2\" id : \"PLAINS\" palette : - GRASSY : 255 vanilla : PLAINS erodible : true flora : chance : 60 attempts : 1 items : TALL_GRASS : weight : 160 y : min : 62 max : 84 GRASS : weight : 100 y : min : 62 max : 84 POPPY : weight : 8 y : min : 62 max : 84 trees : density : 20 items : OAK : weight : 1 y : min : 58 max : 72 If you want to go to the next level, please take a look at [[Multi-layered-Noise-Equations]]","title":"Biome Noise Equation"},{"location":"guides/config/My-First-Noise-Equation/#biome-noise-equation","text":"At the heart of Terra's terrain generation is the noise-equation key found in all biome configs. Here's an example: noise-equation : \"((-(y / 62)^2) + 1) + ((noise2(x, z)+0.5) / 3)\" This page is a tutorial, which will demonstrate how to create an equation to produce your desired type of terrain.","title":"Biome Noise Equation"},{"location":"guides/config/My-First-Noise-Equation/#oh-no-math-what-does-it-mean","text":"The principle behind the noise equation is very simple. The equation takes in 3 variables, x , y and z , and converts them into an output. When Terra is generating the chunk base (Base generation is the first phase of terrain generation, where the shape of the terrain is defined), the current coordinates are fed into this equation. If the result is positive, the location is solid. If the result is negative, the location is air.","title":"Oh no, math! What does it mean?"},{"location":"guides/config/My-First-Noise-Equation/#example","text":"Let's start with a very simple noise equation: noise-equation : \"(-y/64)+1\" This is simply a linear equation, with no noise involved. The result this gives is incredibly boring, a perfectly flat world: Notice that ground level is at Y=64, since when a value lower than 64 is passed into the equation for Y, the result is positive, causing all blocks at Y=63 and lower to be solid. If you graph the equation, you can clearly see the relationship:","title":"Example"},{"location":"guides/config/My-First-Noise-Equation/#this-is-boring-how-can-we-make-actual-terrain","text":"With noise, of course! Terra contains 2 custom functions you can include in your equations, noise2(x, z) and noise3(x, y, z) . These functions exist to, as their names suggest, provide noise to use in your terrain. They provide noise from a Simplex Octave generator, seeded with the world seed, with octaves and frequencies defined in Terra's world config. Below is an example of Simplex Noise. As you can see, the noise creates a gradient. This is useful in terrain generation, as it allows variation to be added to terrain. Let's start with a simple 2D Simplex height map! noise-equation : \"(-y/64)+1 + noise2(x, z)\" This equation adds the 2D Simplex noise fetched from the X and Z coordinates to the linear equation we defined previously. Now, our world looks like this:","title":"This is boring. How can we make actual terrain?"},{"location":"guides/config/My-First-Noise-Equation/#hold-on-what-exactly-is-happening-there","text":"Basically, since we are adding the result of the Simplex Noise (Which ranges from -1.0 to 1.0 and follows a Gaussian Distribution ) to the original equation, we are \"offsetting\" the base height (Y=63) of the terrain by whatever the result of the Simplex operation is. This creates nice hills/mountains in our terrain, and grants us many configuration possibilities!","title":"Hold on, what exactly is happening there?"},{"location":"guides/config/My-First-Noise-Equation/#too-hilly-how-can-we-get-flatter-terrain","text":"Divide the noise result by a number, of course! Here's a new equation, which divides the noise value by 2: noise-equation : \"(-y/64)+1 + noise2(x, z)/2\" And here's what the terrain looks like now:","title":"Too hilly. How can we get flatter terrain?"},{"location":"guides/config/My-First-Noise-Equation/#improving-the-base-equation","text":"I have found that for most cases, a linear base equation is not ideal. For a majority of my biomes, I use a quadratic equation as a base. Specifically, I use: noise-equation : \"-((y / 64)^2) + 1\" The above equation gives a similar result to the linear equation, except it \"drops off\" faster at higher Y-values. Here's the terrain generated from the equation: noise-equation : \"-((y / 64)^2) + 1 + noise2(x, z) / 2\" Add some flora and trees, and we now have a pretty nice Plains biome! noise-equation : \"-((y / 64)^2) + 1 + noise2(x, z) / 2\" id : \"PLAINS\" palette : - GRASSY : 255 vanilla : PLAINS erodible : true flora : chance : 60 attempts : 1 items : TALL_GRASS : weight : 160 y : min : 62 max : 84 GRASS : weight : 100 y : min : 62 max : 84 POPPY : weight : 8 y : min : 62 max : 84 trees : density : 20 items : OAK : weight : 1 y : min : 58 max : 72 If you want to go to the next level, please take a look at [[Multi-layered-Noise-Equations]]","title":"Improving the base equation"},{"location":"guides/config/Noise/","text":"What is noise? Why is noise important? Noise Basics Demonstration Determinism Seeds Flavors of Noise Multidimensional Noise Segmentation Applying Noise to World Generation Coherent Noise Noise Segmentation Manipulating Noise Noise Configs Noise Tool Frequency In Context Fractal Noise Domain Warping Chained Functions Conclusion What is noise? \u00b6 In Terra, noise does not refer to sound you can hear, but rather a series of randomly generated values. These values are produced by something we will call a noise function * - which is just a fancy algorithm that converts an input into a randomized numeric output. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Input parameters \u2502 \u2192 > Noise Function > \u2192 \u2502 Randomized output \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 (aka 'noise') \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Why is noise important? \u00b6 Noise is a central concept in Terra, because just about every random aspect of world generation is influenced by noise to some degree. Having a basic understanding of noise and how to manipulate it will give you insight into how worlds are randomly generated by Terra, and is an important skill to have if you want to develop your own config packs. Before learning how to manipulate noise, you should first have an understanding of the underlying concepts outlined here. Don't worry, we won't throw anything too complicated at you for now! Having a firm grasp on noise will bring you closer to controlling exactly how world generation will behave, which is why having a foundational understanding is important. Here is just a short of list of things heavily influenced by noise in Terra: The placement of biomes in the world. How terrain is shaped. How flora and trees are distributed. Noise Basics \u00b6 Here we will cover some key points is grasping noise in Terra. If you feel like certain concepts are too difficult to understand, feel free to skim over them for now, and revisit them later. Demonstration \u00b6 Let's begin with a demonstration displaying the most basic process of 'creating' noise. We will use a theoretical implementation of a noise function called white noise , and generate some values with it. Explaining how exactly our white noise function creates these values is outside the scope of this guide, however is not essential in understanding the general idea. We will perform a couple samples with our function, using numbers 1 - 10 as an input, and record the outputs as both a number and a shade from black to white. Conventionally, the values outputted by a noise function will be within a range of -1 to 1. We can visualize the relationship between the value and shade on a number line as such: We will also round the output to one decimal place for simplicity. (Typical outputs will produce decimals with much higher precision than just one decimal place!) MODEL \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Input parameters \u2502 \u2192 > White Noise > \u2192 \u2502 Randomized output \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Function \u2502 \u2502 within range [-1, 1] \u2502 \u2502 Number from 1 - 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 RESULTS \u00b6 Simple, right? All our noise function does is convert one value to another. You can think of noise functions like a little number machine that takes an input and scrambles it around to produce an output. SIDE NOTE \u00b6 Input numbers do not have to be whole numbers! This means you can input numbers like 1.5 and noise functions will work still the same way. We've just used integers here for the sake of demonstration. Determinism \u00b6 One requirement of Terra noise functions is that the output must be deterministic , meaning given any input, the output must always be the same. This means we can reliably re-produce any 'random' results we get from noise functions by feeding it the same input. Going off the results above, when passing the number 5 to our white noise function, we will always get the number 0.4 back. Seeds \u00b6 Sometimes, we want to use the same input, and same noise function, but for multiple random unique outputs. In that case, we can use a seed in our noise function. Seeds are basically a way of getting a whole new uncorrelated set of random values from the same inputs + noise function. Unlike the input value, seeds must be a whole number, meaning 5324 would be a valid seed, but 231.23 would not. Expanding on our basic model of noise generation we have: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Input parameters \u2502 \u2192 > Noise Function > \u2192 \u2502 Randomized output \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 - Seed \u2502 \u2502 - Input value \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Here is an example using two different seeds to produce different outputs, using the same inputs and noise function from the example above. Seed = 0 Seed = 1 One usage of seeds that you might be familiar with is minecraft world seeds. A vanilla minecraft world seed gets inserted into the many noise functions that govern vanilla world generation, resulting in completely different worlds per seed (since each noise function will return a completely new set of values for each unique seed). Combined with determinism , we're able to produce new unique randomized worlds by picking a random seed, while also being able to generate the exact same world* provided we use the same seed. VANILLA BEDROCK GENERATION TRIVIA \u00b6 Some noise functions in vanilla generation use the same seed for every world (meaning they don't factor in the world seed), which can result in every world generating a certain characteristic the exact same way. One notable example - the function that controls bedrock formation uses a static seed for every world, leading every vanilla generated world to share the same random configuration of bedrock. Within Terra world generation, all noise producing functions use a combination of the world seed and a value called salt , to determine its own seed. Salt is a number you specify when defining noise configurations, and simply gets added to the world seed. This allows individual noise configurations to use new sets of output values, while sharing the same base noise function. Flavors of Noise \u00b6 There are many variants and implementations of noise functions, such as our white noise function above. Each has their own quirks, behaviors, and applications, however in general they all follow the same basic principles outlined here. We will cover a couple of these variants later down the line. Here is a small list of notable noise functions that are commonly used in Terra: Simplex Noise Cellular / Voronoi / Worley Noise White Noise Value Noise Multidimensional Noise \u00b6 The phrase 'multidimensional noise' may sound intimidating, but don't worry, it's a fairly simple concept to understand. Simply put, multidimensional noise involves providing multiple input values, rather than just one. In every example thus far, we have only provided one value for each noise 'sample' (excluding the seed), meaning we are conceptually only sampling in one dimension, however we can go further. The simplest example of multidimensional noise is just adding one extra input to our noise function, for a grand total of 2 inputs. Conveniently, that gives us 2 dimensions, thus we can easily display a set of 2D samples in a grid. We will refer to the first input as X , and the second as Z . In a new example, let's use a range of 1 - 3 for both X and Z , giving us a total of 9 samples (3 x 3). We will only label the X & Z axes for the sake of simplicity. TWO DIMENSIONAL MODEL \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Input parameters \u2502 \u2192 > White Noise > \u2192 \u2502 Randomized output \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Function \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 - Seed \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 Displayed as as a \u2502 | - Input 1 (X) | \u2502 2D grid of shades \u2502 | - Input 2 (Z) | \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 RESULTS \u00b6 As you can see, all we have done is added another dimension to our white noise function, allowing for noise to be depicted as a 2D grid, rather than a list of values. Taking this experiment further, let's use a larger sample size of 64 x 64: What we have done here is essentially produced a random image using our white noise function. By default, we will assume the above format of visualizing noise in 2D as an image, where each output value represents a grayscale pixel. HIGHER DIMENSIONS \u00b6 Many noise algorithms support an arbitrary amount of inputs, meaning that we can sample noise in any number of dimensions. Typically, we will only use up to three dimensions in Terra, where each input corresponds to the position on each axis X , Y , and Z . Segmentation \u00b6 Segmentation in this context refers to splitting a set of values into several parts based on the range each value fits in to. This is not a concept specific to noise, but is something to keep in mind, as it is commonly used in conjunction with noise and world generation. The simplest form of segmentation is thresholding , which simply involves separating a set of values into two groups based on whether they're higher or lower than a number . An example of thresholding would be outputting a value of -1 for input values less than 0 , and outputting a value of 1 for every other input, however the output could be anything, such as true / false depending on use. Applying a threshold to every pixel of an image where input = intensity of the pixel , output = either a black or white pixel , and threshold = 50% , we get the following result: AS A MATH FUNCTION \u00b6 We can represent thresholding mathematically as a piecewise function: f(x) = { -1 if x < threshold 1 if x >= threshold } Most applications of segmentation in Terra are essentially fancy piecewise functions like the one above, written programmatically. Segmentation is a useful concept to understand when combined with noise, as it allows us to split noise functions into distinct values. We will cover an example of segmented noise and an application of it in the following section. Applying Noise to World Generation \u00b6 You might be wondering: How does this information translate to generating an entire world? Before we jump straight from simple noise generation to generating entire worlds, let's just keep it simple and apply the knowledge we've covered thus far to a simple application. PLANTING GRASS \u00b6 Let's say we have a patch of land, and we want to generate some tall grass on it, how would we determine where the grass goes? The first thing we will want to do is define some basic rules for generating grass, before we get to the part where noise is involved: Grass may only generate on top of Grass Blocks . Grass may only replace Air . Simple enough, now we know that grass will only generate where appropriate. With only these rules however, we would end up with grass on top of every single grass block! What if we only wanted it on some grass blocks? Well we can use our white noise function for that! Let's feed our X & Z world coordinates & seed into our 2D white noise function, which will give us a randomized output value (from -1 to 1 as discussed) for every X-Z column for any given world seed. We will then use that output value to determine whether we place some grass or not. The way this will be determined is by simply thresholding it! We'll start with a threshold of 0 , where any value below our threshold will mean place grass . GRASS PLACEMENT MODEL \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Input parameters \u2502 \u2192 > White Noise > \u2192 \u2502 Randomized output \u2502 \u2192 > Threshold Function \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Function \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 - World Seed \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 A value from \u2502 \u2502 If below the threshold, \u2502 | - X Coordinate \u2502 \u2502 -1 to 1 \u2502 \u2502 place grass. (Displayed \u2502 | - Z Coordinate \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 as a green pixel) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 RESULTS \u00b6 As you can see, we now have a method of randomly determining if grass should be placed or not for any given X-Z coordinate in any world . We can even reduce / increase how much grass we get by modifying our threshold value: Threshold = -0.25 Lowering the threshold from 0 to -0.25 results in less grass because we are effectively removing the values between -0.25 and 0 from falling below the threshold. Conversely, increasing the threshold will result in more grass, as more values will fall below the threshold. Combining this with our rules we established earlier, we now have a method of checking for any block whether it should be grass or not. Coherent Noise \u00b6 Thus far, we have only covered noise that outputs seemingly random tv-static-like values, which is fine for simple applications like the grass example above. But how can we get noise capable of producing smooth rolling hills, vast mountains, and other structured random generation? Let's place the white noise function under the category 'random noise' , and introduce a new category of noise functions called 'coherent noise' . WHAT'S THE DIFFERENCE? \u00b6 The main difference that separates random noise from coherent noise is that while random noise functions produce noise with no apparent structure, coherent noise functions produce 'structured' noise, where adjacent input values produce correlated output values. To get a better idea of the difference, here is a visualization of two different 2D sampled noise functions that both share the same inputs: Random | Coherent As you can see, the coherent noise example has a discernible structure where output values are smooth, compared to the random noise example where there's no apparent structure. The coherent noise function used above is known as Simplex noise , and is one of the many flavors of noise provided in Terra. Noise Segmentation \u00b6 Now that we have introduced coherent noise, we can provide a better visual example of noise segmentation . Let's use the following list of colors and distribute them across a noise function via segmentation: colors : - Red - Yellow - Green - Blue ``` Since we know that [noise outputs will generally be between -1 and 1](#demonstration), we will need to assign each color its own a range *within* the output range `[-1, 1]`. To do this, it's helpful to visualize things on a number line like so : <img src=\"images/noise/basic_example-05.png\" width=\"75%\"> From this we can intuitively see that `blue` corresponds to the range `[-1, 0.5]`, `green` to `[-0.5, 0]` and so on. Thankfully, you won't ever have to define every range required for segmentation by hand, as Terra will automatically segment noise for you, but it's still useful to get an idea of what is happening behind the scenes. Let's finally segment some *simplex noise* by categorizing the output values into our colors based on the range they fit in. <img src=\"images/noise/posterized_opensimplex2_64x64.png\" width=\"25%\"> This is where the usefulness of segmentation comes in - *we can treat these colors as anything*, whether that is a set of biomes, a pattern of blocks, or anything else that requires a list and a noise function. For example, `red` could represent a tropical island biome, `yellow` a beach, `green` shallow ocean, and `blue` deep ocean. Generally lists like this will be defined as a [weighted pool](./Weighted-Pools) such that you can easily weigh certain items to take up more space as needed. As an example, here is what our new biome list may look like : ``` yaml biomes : - TROPICAL_ISLAND : 1 - BEACH : 1 - SHALLOW_OCEAN : 1 - DEEP_OCEAN : 1 Manipulating Noise \u00b6 Now that we have covered some essential topics regarding noise, let's talk about creating, configuring, stretching, squishing, tweaking, and remixing it! Noise Configs \u00b6 So how exactly does this information translate to actually configuring noise in Terra? This is where we will introduce noise configs . When configuring config packs many options will require a noise config, which is written in YAML just like most other areas of pack development. The simplest noise config just requires a type , which defines the noise function for use in the context of a noise config definition. Here what that would look like: type : <Noise Type> We can bring back our white noise function from earlier, which has type WhiteNoise , and insert it into the template above, giving us the following noise config: type : WhiteNoise NOISE CONFIG PARAMETERS \u00b6 In addition to specifying the noise function to use, the type key will also determine what other keys become available as either required or optional when defining a noise config. Some type s will have additional keys that need to be specified to function properly, and others like WhiteNoise don't require anything extra. One example of an optional key available when specifying the WhiteNoise type is salt . The function of salt is covered in Seeds if you need a refresher. Here is what the above example looks like with the salt key added: type : WhiteNoise salt : 2321 Another thing to note is that most optional parameters have a pre-defined default value that's set when not specified. When the salt key is not included in a noise config, it will default to its predefined value 0 . Noise Tool \u00b6 Now that we know how to write a simple noise config, we can use a handy program aptly named the Noise Tool to preview what our config looks like. The Noise Tool was specially designed for creating, previewing, and modifying noise configs, and is also what was used to generate every image of noise used on this page. You can find the Noise Tool on GitHub - Source Download TIP \u00b6 We suggest that you follow along the rest of this section with the Noise Tool, so you can try out parameters get the hang of writing your own noise configs. Playing around and experimenting on your own is a great way of learning what each parameter does, and will give you an intuition on how you can fine tune them to your advantage. For a complete list of noise function type s and their parameters available in Terra, please refer to the Noise Configuration documentation. Frequency \u00b6 You might be wondering how we control just how large or how small details produced by noise functions are - This is where the concept of frequency comes in. Frequency is a number that modifies the scale of noise, where higher frequency produces more 'zoomed out' noise, while lower frequency results in more 'zoomed in' noise. Let's preview some comparisons of the same noise function with varying frequencies: 2x Frequency | 1x Frequency | 0.5x frequency As a general rule of thumb: HIGHER FREQUENCY \u00b6 Zooms out . Produces smaller & closer details. Increases the density of 'points' per unit of space. LOWER FREQUENCY \u00b6 Zooms in . Produces larger & more spread out details. Decreases the density of 'points' per unit of space. IN A NOISE CONFIG \u00b6 Frequency can be defined for applicable types s via the frequency key like so: type : <Noise Type> frequency : <Desired Frequency> Something to note is that tweaking frequency is only really useful for functions in the coherent noise category. You're able to modify the frequency of random noise based functions, however they don't have the property of being able to scale like coherent noise functions do. There isn't much reason to scale the frequency of a random noise function, as doing so functionally has same effect as changing the seed. Under The Hood - How frequency works The driving math behind frequencies is very simple: *multiply the input coordinates of a noise function by the frequency*. Here is a model of the process: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Input parameters \u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u252c \u2192 > Noise Function > \u2192 \u2502 Randomized output \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 - Seed > \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u2502 \u2502 - Frequency > \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 | - Input 1 (X) > \u2192 X * Frequency \u2524 | - Input 2 (Z) > \u2192 Y * Frequency \u256f \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 For example, if we have a frequency of `2`, and want to sample the coordinates `(X = 3, Z = 2)`, first the coordinates will be multiplied by the frequency `2`, giving us the scaled coordinates `(X' = 6, Z' = 4)`. This new set of coordinates will then be input into the noise function which will then give us the final output value. > Based on this logic, we can deduct that the input: > > `(X = 3, Z = 2, Frequency = 2)` > > Will give the exact same output when inputting: > > `(X = 6, Z = 4, Frequency = 1)` Higher frequencies effectively produce *faster changes* when incrementing input coordinates, which is why higher frequencies make details closer and therefore smaller. In Context \u00b6 To get a better idea of how noise configs get used in packs, Here is what one looks like in the context of a palette configuration . The noise config is highlighted in green, and the key it's defined under is highlighted in yellow. id: DIRTY_GRASS layers: - # Single layer of grass and dirt blocks layers: 1 - materials: - - \"minecraft:grass_block\": 1 - - \"minecraft:coarse_dirt\": 1 ! noise: + type: OpenSimplex2 + frequency: 0.05 - # Two layers of dirt below the top layer layers: 2 materials: \"minecraft:dirt\" - # Then finally stone layers: 1 materials: \"minecraft:stone\" The usage of noise here controls the arrangement of the weighted pool of materials highlighted in red. To get a better idea of the relationship, here is a screenshot of a biome which uses the above palette configuration: This is also another great example of noise segmentation in action with weighted pools. You can see our OpenSimplex2 function has been segmented equally between grass blocks and dirt, giving us a nice random pattern of surface blocks in the biome. Fractal Noise \u00b6 In some situations, coherent noise on its own may be far too smooth and uniform to produce ' realistic ' results. Looking at the images above, you may notice plain simplex is quite blobby , which may not be desired for applications where more detail is required. This is where fractal noise comes in. The basic premise of fractal noise that we can produce more detail by stacking multiple of the same noise function on top of each other, where each successive function (called an octave ) has a higher frequency and a scaled down output value (making it contribute less to the overall noise). This process of progressively stacking incrementally smaller noise layers to produce a fractal effect is referred to as fractal Brownian motion (Commonly abbreviated as fBm). It might sound quite complicated in writing, so we can demonstrate this concept visually to get a better idea of what's happening: 1 Octave (Regular Noise) | 2 Octaves | 3 Octaves | 4 Octaves As you can see, the more octaves we add, the more detailed the noise gets. This is the main application of fractal noise - to produce more detail, especially at lower frequencies where detail is sparse. You won't have to worry about the exact math behind how each octave gets stacked, as Terra will handle all of that for you. IN A NOISE CONFIG \u00b6 When fractalizing noise configs, we define the fractalizer as its own noise config , which takes another noise config as an input. The syntax for this is as followed: type : <Fractalizer Type> function : type : ... # Noise config to be fractalized As you can see, we have the main noise config for our fractalizer, and a second noise config nested inside under the function key. The function key is the only required parameter for all fractalizers. Based on this template, we can create a real noise config. Let's use the fBm fractalizer, with an input function with type OpenSimplex2 : type : fBm function : type : OpenSimplex2 Pretty simple, all we've done is passed some simplex noise into the fBm function. Fractalizers have a couple additional parameters, including octaves , lacunarity , and gain . Here is another example config with those parameters already defined: type : fBm function : type : OpenSimplex2 octaves : 3 lacunarity : 2 gain : 0.75 Feel free to preview this config in the Noise Tool , and have an experiment with each parameter to see what they all do. To see all available fractalizers and their parameters, please refer to the Noise Configuration documentation. Domain Warping \u00b6 Similar to fractal noise, domain warping involves manipulating the input aka the domain **, before it's passed to the noise function. More specifically, the domain of a noise function will be warped via translation by the output of a secondary warping function. To demonstrate domain warping more clearly, let's take a 64 x 64 square of samples in a space. Our function to be warped will be a checkerboard pattern, and our warping function will be some basic simplex noise. When domain warping the checker board function by the simplex we get the following result: As you can see, our once perfectly square boxes have been contorted out of shape by the warp function. IN A NOISE CONFIG \u00b6 To use domain warping, we will need to set the type to DomainWarp , and specify two additional required keys function and warp . As you may have already guessed, both function and warp need to be set to a noise config, similar to how fractalizers accept an input function: type : DomainWarp function : type : ... # Noise config to be warped warp : type : ... # Warp noise config Additionally, we can specify amplitude which determines how much the function defined in function will be warped by the warp function. Here is an example of a real noise config which warps low frequency simplex with another simplex function: type : DomainWarp function : type : OpenSimplex2 frequency : 0.005 warp : type : OpenSimplex2 amplitude : 20 Again it's recommended that you try out this noise config in the Noise Tool and see what changing each parameter does - What happens if you use WhiteNoise as a warp function instead? Under The Hood - The Math Behind Domain Warping To get an in depth understanding of what's happening, let's explain the formula that is used to achieve domain warping: > > * We will define `noise(coordinate)` as our function to be warped, where `coordinate` represents the input values > (such as the familiar `X` and `Z` coordinates). > > * To *translate* `noise`, we can simply add some translation to the input: `noise(coordinate + translation)`. > Translating simply means moving left / right / up / down / etc. > > * We can then define `warp_noise(coordinate)` as our warping function. > > * If we make `translation` our `warp_noise` function then now the `coordinate` of `noise` will be translated by > `warp_noise` like so: > > `noise(coordinate + warp_noise(coordinate))` > > * Finally, we can multiply the output of `warp_noise` by a value `amplitude`, which will control how 'strong' the > warping will be, to give us the final formula: > > `noise(coordinate + warp_noise(coordinate) * amplitude)` Chained Functions \u00b6 Because some keys such as function and warp accept a noise config, something we can do is feed a domain warp function into another domain warp function . In fact, we could feed any noise function into any other one, given it has a parameter that accepts a noise config. This is incredibly powerful, as it allows for constructing complex highly configurable systems of noise. Here is an example where we domain warp some fractalized simplex by more fractalized simplex (which has also been domain warped by more... fractalized simplex!): type : DomainWarp amplitude : 300 function : type : fBm function : type : OpenSimplex2 frequency : 0.002 warp : type : DomainWarp amplitude : 20 function : type : fBm function : type : OpenSimplex2 frequency : 0.003 warp : type : fBm function : type : OpenSimplex2 frequency : 0.02 Conclusion \u00b6 Now that you've got an idea of what noise is , how it works , and a couple ways of manipulating it , you should now be equipped with the necessary knowledge to start configuring your own fancy noise functions for use in your own customized world generation! For more information on the available noise functions in Terra, please refer to the Noise Configuration documentation. If you have any further questions, feel free to ask us in our Discord !","title":"Noise"},{"location":"guides/config/Noise/#what-is-noise","text":"In Terra, noise does not refer to sound you can hear, but rather a series of randomly generated values. These values are produced by something we will call a noise function * - which is just a fancy algorithm that converts an input into a randomized numeric output. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Input parameters \u2502 \u2192 > Noise Function > \u2192 \u2502 Randomized output \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 (aka 'noise') \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"What is noise?"},{"location":"guides/config/Noise/#why-is-noise-important","text":"Noise is a central concept in Terra, because just about every random aspect of world generation is influenced by noise to some degree. Having a basic understanding of noise and how to manipulate it will give you insight into how worlds are randomly generated by Terra, and is an important skill to have if you want to develop your own config packs. Before learning how to manipulate noise, you should first have an understanding of the underlying concepts outlined here. Don't worry, we won't throw anything too complicated at you for now! Having a firm grasp on noise will bring you closer to controlling exactly how world generation will behave, which is why having a foundational understanding is important. Here is just a short of list of things heavily influenced by noise in Terra: The placement of biomes in the world. How terrain is shaped. How flora and trees are distributed.","title":"Why is noise important?"},{"location":"guides/config/Noise/#noise-basics","text":"Here we will cover some key points is grasping noise in Terra. If you feel like certain concepts are too difficult to understand, feel free to skim over them for now, and revisit them later.","title":"Noise Basics"},{"location":"guides/config/Noise/#demonstration","text":"Let's begin with a demonstration displaying the most basic process of 'creating' noise. We will use a theoretical implementation of a noise function called white noise , and generate some values with it. Explaining how exactly our white noise function creates these values is outside the scope of this guide, however is not essential in understanding the general idea. We will perform a couple samples with our function, using numbers 1 - 10 as an input, and record the outputs as both a number and a shade from black to white. Conventionally, the values outputted by a noise function will be within a range of -1 to 1. We can visualize the relationship between the value and shade on a number line as such: We will also round the output to one decimal place for simplicity. (Typical outputs will produce decimals with much higher precision than just one decimal place!)","title":"Demonstration"},{"location":"guides/config/Noise/#determinism","text":"One requirement of Terra noise functions is that the output must be deterministic , meaning given any input, the output must always be the same. This means we can reliably re-produce any 'random' results we get from noise functions by feeding it the same input. Going off the results above, when passing the number 5 to our white noise function, we will always get the number 0.4 back.","title":"Determinism"},{"location":"guides/config/Noise/#seeds","text":"Sometimes, we want to use the same input, and same noise function, but for multiple random unique outputs. In that case, we can use a seed in our noise function. Seeds are basically a way of getting a whole new uncorrelated set of random values from the same inputs + noise function. Unlike the input value, seeds must be a whole number, meaning 5324 would be a valid seed, but 231.23 would not. Expanding on our basic model of noise generation we have: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Input parameters \u2502 \u2192 > Noise Function > \u2192 \u2502 Randomized output \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 - Seed \u2502 \u2502 - Input value \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Here is an example using two different seeds to produce different outputs, using the same inputs and noise function from the example above. Seed = 0 Seed = 1 One usage of seeds that you might be familiar with is minecraft world seeds. A vanilla minecraft world seed gets inserted into the many noise functions that govern vanilla world generation, resulting in completely different worlds per seed (since each noise function will return a completely new set of values for each unique seed). Combined with determinism , we're able to produce new unique randomized worlds by picking a random seed, while also being able to generate the exact same world* provided we use the same seed.","title":"Seeds"},{"location":"guides/config/Noise/#flavors-of-noise","text":"There are many variants and implementations of noise functions, such as our white noise function above. Each has their own quirks, behaviors, and applications, however in general they all follow the same basic principles outlined here. We will cover a couple of these variants later down the line. Here is a small list of notable noise functions that are commonly used in Terra: Simplex Noise Cellular / Voronoi / Worley Noise White Noise Value Noise","title":"Flavors of Noise"},{"location":"guides/config/Noise/#multidimensional-noise","text":"The phrase 'multidimensional noise' may sound intimidating, but don't worry, it's a fairly simple concept to understand. Simply put, multidimensional noise involves providing multiple input values, rather than just one. In every example thus far, we have only provided one value for each noise 'sample' (excluding the seed), meaning we are conceptually only sampling in one dimension, however we can go further. The simplest example of multidimensional noise is just adding one extra input to our noise function, for a grand total of 2 inputs. Conveniently, that gives us 2 dimensions, thus we can easily display a set of 2D samples in a grid. We will refer to the first input as X , and the second as Z . In a new example, let's use a range of 1 - 3 for both X and Z , giving us a total of 9 samples (3 x 3). We will only label the X & Z axes for the sake of simplicity.","title":"Multidimensional Noise"},{"location":"guides/config/Noise/#segmentation","text":"Segmentation in this context refers to splitting a set of values into several parts based on the range each value fits in to. This is not a concept specific to noise, but is something to keep in mind, as it is commonly used in conjunction with noise and world generation. The simplest form of segmentation is thresholding , which simply involves separating a set of values into two groups based on whether they're higher or lower than a number . An example of thresholding would be outputting a value of -1 for input values less than 0 , and outputting a value of 1 for every other input, however the output could be anything, such as true / false depending on use. Applying a threshold to every pixel of an image where input = intensity of the pixel , output = either a black or white pixel , and threshold = 50% , we get the following result:","title":"Segmentation"},{"location":"guides/config/Noise/#applying-noise-to-world-generation","text":"You might be wondering: How does this information translate to generating an entire world? Before we jump straight from simple noise generation to generating entire worlds, let's just keep it simple and apply the knowledge we've covered thus far to a simple application.","title":"Applying Noise to World Generation"},{"location":"guides/config/Noise/#coherent-noise","text":"Thus far, we have only covered noise that outputs seemingly random tv-static-like values, which is fine for simple applications like the grass example above. But how can we get noise capable of producing smooth rolling hills, vast mountains, and other structured random generation? Let's place the white noise function under the category 'random noise' , and introduce a new category of noise functions called 'coherent noise' .","title":"Coherent Noise"},{"location":"guides/config/Noise/#noise-segmentation","text":"Now that we have introduced coherent noise, we can provide a better visual example of noise segmentation . Let's use the following list of colors and distribute them across a noise function via segmentation: colors : - Red - Yellow - Green - Blue ``` Since we know that [noise outputs will generally be between -1 and 1](#demonstration), we will need to assign each color its own a range *within* the output range `[-1, 1]`. To do this, it's helpful to visualize things on a number line like so : <img src=\"images/noise/basic_example-05.png\" width=\"75%\"> From this we can intuitively see that `blue` corresponds to the range `[-1, 0.5]`, `green` to `[-0.5, 0]` and so on. Thankfully, you won't ever have to define every range required for segmentation by hand, as Terra will automatically segment noise for you, but it's still useful to get an idea of what is happening behind the scenes. Let's finally segment some *simplex noise* by categorizing the output values into our colors based on the range they fit in. <img src=\"images/noise/posterized_opensimplex2_64x64.png\" width=\"25%\"> This is where the usefulness of segmentation comes in - *we can treat these colors as anything*, whether that is a set of biomes, a pattern of blocks, or anything else that requires a list and a noise function. For example, `red` could represent a tropical island biome, `yellow` a beach, `green` shallow ocean, and `blue` deep ocean. Generally lists like this will be defined as a [weighted pool](./Weighted-Pools) such that you can easily weigh certain items to take up more space as needed. As an example, here is what our new biome list may look like : ``` yaml biomes : - TROPICAL_ISLAND : 1 - BEACH : 1 - SHALLOW_OCEAN : 1 - DEEP_OCEAN : 1","title":"Noise Segmentation"},{"location":"guides/config/Noise/#manipulating-noise","text":"Now that we have covered some essential topics regarding noise, let's talk about creating, configuring, stretching, squishing, tweaking, and remixing it!","title":"Manipulating Noise"},{"location":"guides/config/Noise/#noise-configs","text":"So how exactly does this information translate to actually configuring noise in Terra? This is where we will introduce noise configs . When configuring config packs many options will require a noise config, which is written in YAML just like most other areas of pack development. The simplest noise config just requires a type , which defines the noise function for use in the context of a noise config definition. Here what that would look like: type : <Noise Type> We can bring back our white noise function from earlier, which has type WhiteNoise , and insert it into the template above, giving us the following noise config: type : WhiteNoise","title":"Noise Configs"},{"location":"guides/config/Noise/#noise-tool","text":"Now that we know how to write a simple noise config, we can use a handy program aptly named the Noise Tool to preview what our config looks like. The Noise Tool was specially designed for creating, previewing, and modifying noise configs, and is also what was used to generate every image of noise used on this page. You can find the Noise Tool on GitHub - Source Download","title":"Noise Tool"},{"location":"guides/config/Noise/#frequency","text":"You might be wondering how we control just how large or how small details produced by noise functions are - This is where the concept of frequency comes in. Frequency is a number that modifies the scale of noise, where higher frequency produces more 'zoomed out' noise, while lower frequency results in more 'zoomed in' noise. Let's preview some comparisons of the same noise function with varying frequencies: 2x Frequency | 1x Frequency | 0.5x frequency As a general rule of thumb:","title":"Frequency"},{"location":"guides/config/Noise/#in-context","text":"To get a better idea of how noise configs get used in packs, Here is what one looks like in the context of a palette configuration . The noise config is highlighted in green, and the key it's defined under is highlighted in yellow. id: DIRTY_GRASS layers: - # Single layer of grass and dirt blocks layers: 1 - materials: - - \"minecraft:grass_block\": 1 - - \"minecraft:coarse_dirt\": 1 ! noise: + type: OpenSimplex2 + frequency: 0.05 - # Two layers of dirt below the top layer layers: 2 materials: \"minecraft:dirt\" - # Then finally stone layers: 1 materials: \"minecraft:stone\" The usage of noise here controls the arrangement of the weighted pool of materials highlighted in red. To get a better idea of the relationship, here is a screenshot of a biome which uses the above palette configuration: This is also another great example of noise segmentation in action with weighted pools. You can see our OpenSimplex2 function has been segmented equally between grass blocks and dirt, giving us a nice random pattern of surface blocks in the biome.","title":"In Context"},{"location":"guides/config/Noise/#fractal-noise","text":"In some situations, coherent noise on its own may be far too smooth and uniform to produce ' realistic ' results. Looking at the images above, you may notice plain simplex is quite blobby , which may not be desired for applications where more detail is required. This is where fractal noise comes in. The basic premise of fractal noise that we can produce more detail by stacking multiple of the same noise function on top of each other, where each successive function (called an octave ) has a higher frequency and a scaled down output value (making it contribute less to the overall noise). This process of progressively stacking incrementally smaller noise layers to produce a fractal effect is referred to as fractal Brownian motion (Commonly abbreviated as fBm). It might sound quite complicated in writing, so we can demonstrate this concept visually to get a better idea of what's happening: 1 Octave (Regular Noise) | 2 Octaves | 3 Octaves | 4 Octaves As you can see, the more octaves we add, the more detailed the noise gets. This is the main application of fractal noise - to produce more detail, especially at lower frequencies where detail is sparse. You won't have to worry about the exact math behind how each octave gets stacked, as Terra will handle all of that for you.","title":"Fractal Noise"},{"location":"guides/config/Noise/#domain-warping","text":"Similar to fractal noise, domain warping involves manipulating the input aka the domain **, before it's passed to the noise function. More specifically, the domain of a noise function will be warped via translation by the output of a secondary warping function. To demonstrate domain warping more clearly, let's take a 64 x 64 square of samples in a space. Our function to be warped will be a checkerboard pattern, and our warping function will be some basic simplex noise. When domain warping the checker board function by the simplex we get the following result: As you can see, our once perfectly square boxes have been contorted out of shape by the warp function.","title":"Domain Warping"},{"location":"guides/config/Noise/#chained-functions","text":"Because some keys such as function and warp accept a noise config, something we can do is feed a domain warp function into another domain warp function . In fact, we could feed any noise function into any other one, given it has a parameter that accepts a noise config. This is incredibly powerful, as it allows for constructing complex highly configurable systems of noise. Here is an example where we domain warp some fractalized simplex by more fractalized simplex (which has also been domain warped by more... fractalized simplex!): type : DomainWarp amplitude : 300 function : type : fBm function : type : OpenSimplex2 frequency : 0.002 warp : type : DomainWarp amplitude : 20 function : type : fBm function : type : OpenSimplex2 frequency : 0.003 warp : type : fBm function : type : OpenSimplex2 frequency : 0.02","title":"Chained Functions"},{"location":"guides/config/Noise/#conclusion","text":"Now that you've got an idea of what noise is , how it works , and a couple ways of manipulating it , you should now be equipped with the necessary knowledge to start configuring your own fancy noise functions for use in your own customized world generation! For more information on the available noise functions in Terra, please refer to the Noise Configuration documentation. If you have any further questions, feel free to ask us in our Discord !","title":"Conclusion"},{"location":"guides/config/TerraScript/","text":"What is TerraScript? \u00b6 TerraScript is a custom scripting language with JavaScript-like syntax designed for writing custom structures. It is simple to learn and easy to use, and incredibly powerful at the same time. You can use TerraScript for anything from custom procedurally generated trees, to mineshafts, to villages. What specifically can TerraScript do? \u00b6 TerraScript has many features to allow manipulation of the world, including: * Setting blocks * Setting block NBT data (Spawner NBT data, sign NBT data, etc) * Applying loot tables to inventories * Setting blocks that are auto-pulled to the ground * Spawning entities It can also read data from the world in different ways to allow for efficient structure generation. TerraScript can read: * Location type ( AIR , LAND , or OCEAN ) for fast checking and spawn validation. * Block States for slower, but more accurate checking. * Marks allow scripts to \"mark\" locations, then check them later, in a way that does not affect generation. Perhaps the most powerful part of TerraScript is its ability to generate scripts recursively. TerraScript contains functions to: * Invoke other scripts at offset locations within the current script, and check whether the sub-structure was successfully generated * Check the amount of recursions in the current script TerraScript contains essential language features like: * String, Integer, and Boolean variables * if else if and else statements * for and while loops, with flow control statements ( continue break and return ) In the default, TerraScript is used for: * All custom trees. Most trees are TerraScript schematics made with the export command, others, like Oak and Spruce trees, are procedurally generated. * Procedurally generated villages using recursive scripts * Procedurally generated mineshafts using recursive, completely procedural scripts.","title":"TerraScript"},{"location":"guides/config/TerraScript/#what-is-terrascript","text":"TerraScript is a custom scripting language with JavaScript-like syntax designed for writing custom structures. It is simple to learn and easy to use, and incredibly powerful at the same time. You can use TerraScript for anything from custom procedurally generated trees, to mineshafts, to villages.","title":"What is TerraScript?"},{"location":"guides/config/TerraScript/#what-specifically-can-terrascript-do","text":"TerraScript has many features to allow manipulation of the world, including: * Setting blocks * Setting block NBT data (Spawner NBT data, sign NBT data, etc) * Applying loot tables to inventories * Setting blocks that are auto-pulled to the ground * Spawning entities It can also read data from the world in different ways to allow for efficient structure generation. TerraScript can read: * Location type ( AIR , LAND , or OCEAN ) for fast checking and spawn validation. * Block States for slower, but more accurate checking. * Marks allow scripts to \"mark\" locations, then check them later, in a way that does not affect generation. Perhaps the most powerful part of TerraScript is its ability to generate scripts recursively. TerraScript contains functions to: * Invoke other scripts at offset locations within the current script, and check whether the sub-structure was successfully generated * Check the amount of recursions in the current script TerraScript contains essential language features like: * String, Integer, and Boolean variables * if else if and else statements * for and while loops, with flow control statements ( continue break and return ) In the default, TerraScript is used for: * All custom trees. Most trees are TerraScript schematics made with the export command, others, like Oak and Spruce trees, are procedurally generated. * Procedurally generated villages using recursive scripts * Procedurally generated mineshafts using recursive, completely procedural scripts.","title":"What specifically can TerraScript do?"},{"location":"guides/config/Weighted-Pools/","text":"A weighted pool is a way to randomly select one of many objects from a \"pool\" based on \"weight\". Pools \u00b6 A pool is a list of objects from which selections will be pulled. Weight \u00b6 Weight is the relative probability that any object will be selected from the pool. Each object in the pool has a weight, meaning the chance of object O being selected from pool P is weight(O)/sum(weight(P_n)) . Example \u00b6 Here's an example pool: OPTION_A : 2 OPTION_B : 1 OPTION_C : 1 In this YAML-based pool, the keys are the objects, and the values are the weights. If we want the probability that OPTION_A will be selected, we sum all weights, and divide the weight of OPTION_A by that sum. 2 + 1 + 1 = 4 Therefore the probability that OPTION_A will be selected is 2/4 , or 50%. Manipulating weights to get a desired probability \u00b6 What if we want Option A to have a 60% chance of being selected? This requires manipulating the weights of all objects in the pool, since with B and C having a weight of 1, there is no integer weight that can be assigned to A that will give it a probability of 60%. What is usually done is that the weights are given a set sum that is easy to work with. Usually this is 100, since with a sum of 100, every object's weight is equal to the percent chance it will be selected. By applying this to the above example, we can produce this pool that has a 60% chance of A being selected: OPTION_A : 60 OPTION_B : 20 OPTION_C : 20 Use Cases \u00b6 Sometimes, it is undesirable to have an equal probability of all objects being selected, so you may want to \"weight\" some objects higher, so they are selected more often.","title":"Weighted Pools"},{"location":"guides/config/Weighted-Pools/#pools","text":"A pool is a list of objects from which selections will be pulled.","title":"Pools"},{"location":"guides/config/Weighted-Pools/#weight","text":"Weight is the relative probability that any object will be selected from the pool. Each object in the pool has a weight, meaning the chance of object O being selected from pool P is weight(O)/sum(weight(P_n)) .","title":"Weight"},{"location":"guides/config/Weighted-Pools/#example","text":"Here's an example pool: OPTION_A : 2 OPTION_B : 1 OPTION_C : 1 In this YAML-based pool, the keys are the objects, and the values are the weights. If we want the probability that OPTION_A will be selected, we sum all weights, and divide the weight of OPTION_A by that sum. 2 + 1 + 1 = 4 Therefore the probability that OPTION_A will be selected is 2/4 , or 50%.","title":"Example"},{"location":"guides/config/Weighted-Pools/#manipulating-weights-to-get-a-desired-probability","text":"What if we want Option A to have a 60% chance of being selected? This requires manipulating the weights of all objects in the pool, since with B and C having a weight of 1, there is no integer weight that can be assigned to A that will give it a probability of 60%. What is usually done is that the weights are given a set sum that is easy to work with. Usually this is 100, since with a sum of 100, every object's weight is equal to the percent chance it will be selected. By applying this to the above example, we can produce this pool that has a 60% chance of A being selected: OPTION_A : 60 OPTION_B : 20 OPTION_C : 20","title":"Manipulating weights to get a desired probability"},{"location":"guides/config/Weighted-Pools/#use-cases","text":"Sometimes, it is undesirable to have an equal probability of all objects being selected, so you may want to \"weight\" some objects higher, so they are selected more often.","title":"Use Cases"},{"location":"guides/config/Working-With-Structures/","text":"Terra Structures \u00b6 Terra uses its own structure storage format. THis format is a custom scripting language called TerraScript. For information on how to write procedural structures in TerraScript, see the TerraScript Basics page. This page will go over exporting structures from your world to TerraScript files. Exporting Structures \u00b6 Exporting structures requires WorldEdit installed. You only need WorldEdit for selection, nothing else in Terra requires it. Exporting a structure: 1. Build your structure. For this example, this spruce tree will be used: 2. (Optional) Place a Center Sign in your structure. A Center sign defines a center to the structure around which the script will be made. 3. Make a WorldEdit selection including your structure. (The cobblestone shown in the image was for making the selection, it was removed afterwards) 4. Export your structure with the /te export <name> command. Your structure will be saved to plugins/Terra/export/structures/name.tesf . Loading Structures \u00b6 Loading structures can be useful for debugging. All loaded structure scripts may be loaded via command. Command Syntax \u00b6 /te structure export <name> Export a structure to plugins/Terra/export/structures/name.tesf /te structure load <full|chunk> <id> <rotation> Load a structure script with ID id and rotation rotation * full loads the entire structure * chunk` loads the secton of the structure in the current chunk.","title":"Terra Structures"},{"location":"guides/config/Working-With-Structures/#terra-structures","text":"Terra uses its own structure storage format. THis format is a custom scripting language called TerraScript. For information on how to write procedural structures in TerraScript, see the TerraScript Basics page. This page will go over exporting structures from your world to TerraScript files.","title":"Terra Structures"},{"location":"guides/config/Working-With-Structures/#exporting-structures","text":"Exporting structures requires WorldEdit installed. You only need WorldEdit for selection, nothing else in Terra requires it. Exporting a structure: 1. Build your structure. For this example, this spruce tree will be used: 2. (Optional) Place a Center Sign in your structure. A Center sign defines a center to the structure around which the script will be made. 3. Make a WorldEdit selection including your structure. (The cobblestone shown in the image was for making the selection, it was removed afterwards) 4. Export your structure with the /te export <name> command. Your structure will be saved to plugins/Terra/export/structures/name.tesf .","title":"Exporting Structures"},{"location":"guides/config/Working-With-Structures/#loading-structures","text":"Loading structures can be useful for debugging. All loaded structure scripts may be loaded via command.","title":"Loading Structures"},{"location":"guides/config/Working-With-Structures/#command-syntax","text":"/te structure export <name> Export a structure to plugins/Terra/export/structures/name.tesf /te structure load <full|chunk> <id> <rotation> Load a structure script with ID id and rotation rotation * full loads the entire structure * chunk` loads the secton of the structure in the current chunk.","title":"Command Syntax"},{"location":"guides/install/","text":"Preface \u00b6 Terra's platform-agnostic API allows us to seamlessly support many Minecraft modding platforms, including Fabric, Forge, and the Bukkit ecosystem. If you have already decided on which platform you wish to use, simply choose the quick start guide for your platform: * Fabric * Forge * Bukkit Choosing a Platform \u00b6 If you have not yet decided on a platform, read this section to choose one. Fabric \u00b6 If you want to run Terra in a singleplayer environment, or on a small server with friends, we recommend using Fabric. Our Fabric implementation is the most feature-complete, since Fabric gives us freedom to directly interface with the game in ways impossible on other platforms. Fabric also has many optimization mods which we make sure to support entirely, which allow your game to run extremely well. Bukkit (Paper and friends) \u00b6 If you're running a large server for lots of people, you'll probably want to use Bukkit, simply because of all the plugins available for large servers. We do not recommend using Bukkit for a small server, for that, use Fabric . A Note on Bukkit/Spigot/Paper \u00b6 Lots of people get confused about what the difference is between Bukkit, Spigot, and Paper. TL;DR: \u00b6 Bukkit is an API, a way for developers to interface with and write plugins for the Minecraft server. Spigot is an implementation of the Bukkit API, it's a platform that allows the Minecraft server to load and run Bukkit plugins. Bukkit itself is no longer maintained by the Bukkit team, so now SpigotMC maintains both Bukkit (the API) and Spigot (the implementation). Paper is a fork of Spigot, a project based on Spigot that extends its functionality. Paper adds many performance optimizations to the Minecraft server, and also extends the Bukkit API. What does this have to do with Terra? \u00b6 We refer to the entire Bukkit ecosystem (Bukkit API, Spigot, Paper and friends...) as Bukkit , simply because Bukkit is the name of the API. However: Terra develops against and tests on Paper. We do this because Bukkit and Spigot simply do not expose the required API for Terra to be fully functional. Paper's extended API does. This means that, while Terra will still work on Spigot, there will be (important) features missing. TL;DR: Use Paper, or a fork of Paper. \u00b6 Forge \u00b6 We recommend using Forge only when there are other Forge mods that you want to use with Terra. If you just want to play with Terra, use Fabric instead. If your other mods have Fabric versions, we recommend making the switch. Use Forge if you have Forge-only mods that you want to use with Terra.","title":"Installation"},{"location":"guides/install/#preface","text":"Terra's platform-agnostic API allows us to seamlessly support many Minecraft modding platforms, including Fabric, Forge, and the Bukkit ecosystem. If you have already decided on which platform you wish to use, simply choose the quick start guide for your platform: * Fabric * Forge * Bukkit","title":"Preface"},{"location":"guides/install/#choosing-a-platform","text":"If you have not yet decided on a platform, read this section to choose one.","title":"Choosing a Platform"},{"location":"guides/install/#fabric","text":"If you want to run Terra in a singleplayer environment, or on a small server with friends, we recommend using Fabric. Our Fabric implementation is the most feature-complete, since Fabric gives us freedom to directly interface with the game in ways impossible on other platforms. Fabric also has many optimization mods which we make sure to support entirely, which allow your game to run extremely well.","title":"Fabric"},{"location":"guides/install/#bukkit-paper-and-friends","text":"If you're running a large server for lots of people, you'll probably want to use Bukkit, simply because of all the plugins available for large servers. We do not recommend using Bukkit for a small server, for that, use Fabric .","title":"Bukkit (Paper and friends)"},{"location":"guides/install/#a-note-on-bukkitspigotpaper","text":"Lots of people get confused about what the difference is between Bukkit, Spigot, and Paper.","title":"A Note on Bukkit/Spigot/Paper"},{"location":"guides/install/#tldr","text":"Bukkit is an API, a way for developers to interface with and write plugins for the Minecraft server. Spigot is an implementation of the Bukkit API, it's a platform that allows the Minecraft server to load and run Bukkit plugins. Bukkit itself is no longer maintained by the Bukkit team, so now SpigotMC maintains both Bukkit (the API) and Spigot (the implementation). Paper is a fork of Spigot, a project based on Spigot that extends its functionality. Paper adds many performance optimizations to the Minecraft server, and also extends the Bukkit API.","title":"TL;DR:"},{"location":"guides/install/#what-does-this-have-to-do-with-terra","text":"We refer to the entire Bukkit ecosystem (Bukkit API, Spigot, Paper and friends...) as Bukkit , simply because Bukkit is the name of the API. However: Terra develops against and tests on Paper. We do this because Bukkit and Spigot simply do not expose the required API for Terra to be fully functional. Paper's extended API does. This means that, while Terra will still work on Spigot, there will be (important) features missing.","title":"What does this have to do with Terra?"},{"location":"guides/install/#tldr-use-paper-or-a-fork-of-paper","text":"","title":"TL;DR: Use Paper, or a fork of Paper."},{"location":"guides/install/#forge","text":"We recommend using Forge only when there are other Forge mods that you want to use with Terra. If you just want to play with Terra, use Fabric instead. If your other mods have Fabric versions, we recommend making the switch. Use Forge if you have Forge-only mods that you want to use with Terra.","title":"Forge"},{"location":"guides/install/Quick-Start-Guide-for-Bukkit/","text":"This guide is intended for the Bukkit version of Terra. See the Getting Started Page for guides on other platforms. Preface \u00b6 The Bukkit version of Terra supports server platforms such as Spigot , Paper , and further forks such as Tuinity and Purpur . However we highly recommend using Paper, or one of its sane forks (Tuinity, Purpur, etc.), with Terra, since Paper is the Bukkit platform we develop for and support. Terra will not be fully functional with CraftBukkit/Spigot. Some important features require the use of Paper's extended API, and will be missing on platforms such as Spigot! If you have already installed Terra or already know how to install Bukkit plugins, you can skip to Setting up a World . Download & Installation \u00b6 Download the latest stable Terra Bukkit release from the SpigotMC website here . Once you have downloaded the .jar file from Spigot, simply place the file your plugins folder located inside your server root. Once the plugin has been installed, start your server. If your server is already running, do not under any circumstances use the /reload command, or any third party plugin to reload your server, simply restart the server instead! [Why?] Once the the server has restarted, check your console log for the following line to ensure everything has been installed correctly: [XX:XX:XX INFO]: [Terra] DEFAULT vX.X.X by dfsek loaded in XXXX.XXXXms. This means that the plugin has loaded successfully, and that the default Configuration Pack has been unpacked and loaded correctly without issues. TROUBLESHOOTING INSTALLATION \u00b6 If the plugin, or DEFAULT pack failed to load, console will display an error message outlining what went wrong. Be sure to read through the error and double check if you have made a mistake anywhere. If you are unable to install plugin successfully, and have attempted to fix any issues yourself, please feel free to shoot us a message on our Discord server and provide any relevant error logs! Setting up a World \u00b6 Here we will be replacing the server's default world with new world configured through the Bukkit config to use Terra as the new generator. Because we are working with changes to worlds ensure that you have made the necessary backups before making any destructive changes ! We do not recommend changing the generator of an existing world , as this will produce broken chunk borders between old and new terrain. If you would like to use a world manager like Multiverse Core to create a world instead of manually setting it as outlined here, please refer to Creating a Terra World . Procedure \u00b6 Ensure your server is not running. If you missed it above, please make a backup of any relevant world folders in your server directory. If you're using a fresh server you won't need to worry about this ! Configure your server's world to use the new config as a generator: Navigate to the bukkit.yml file which is also contained within your server directory, and open it with any text editor. Assign your new generator to the default world by adding the following lines to the end of the file : worlds : <LEVEL NAME> : # The name of this can be found in the 'server.properties' file under # the 'level-name' key. By default, level-name is set to 'world'. generator : Terra:DEFAULT Either delete the existing world folder (the name of this folder is covered above) in your server directory, or rename it to something else (for example world_backup ). Boot your server back up. Your server should re-generate the world folder during startup Join your server and check if your new world is using Terra world generation. If you followed the steps correctly without any errors, then you have successfully set up a server with Terra! TROUBLESHOOTING WORLD SETUP \u00b6 In the case that you run into issues during the world set up process, be sure to check you have followed each step correctly. Check for any errors in console and try to interpret what the issue might be. Again you are unable to set up a world successfully, and have attempted to fix any issues yourself, please feel free to shoot us a message on our Discord server and provide any relevant information and or full server logs! Where can I go from here? \u00b6 If you would like to continue learning more about Terra, or would like to see what else you can get out of it, please continue on to the Config Packs page!","title":"Quick Start Guide for Bukkit"},{"location":"guides/install/Quick-Start-Guide-for-Bukkit/#preface","text":"The Bukkit version of Terra supports server platforms such as Spigot , Paper , and further forks such as Tuinity and Purpur . However we highly recommend using Paper, or one of its sane forks (Tuinity, Purpur, etc.), with Terra, since Paper is the Bukkit platform we develop for and support. Terra will not be fully functional with CraftBukkit/Spigot. Some important features require the use of Paper's extended API, and will be missing on platforms such as Spigot! If you have already installed Terra or already know how to install Bukkit plugins, you can skip to Setting up a World .","title":"Preface"},{"location":"guides/install/Quick-Start-Guide-for-Bukkit/#download-installation","text":"Download the latest stable Terra Bukkit release from the SpigotMC website here . Once you have downloaded the .jar file from Spigot, simply place the file your plugins folder located inside your server root. Once the plugin has been installed, start your server. If your server is already running, do not under any circumstances use the /reload command, or any third party plugin to reload your server, simply restart the server instead! [Why?] Once the the server has restarted, check your console log for the following line to ensure everything has been installed correctly: [XX:XX:XX INFO]: [Terra] DEFAULT vX.X.X by dfsek loaded in XXXX.XXXXms. This means that the plugin has loaded successfully, and that the default Configuration Pack has been unpacked and loaded correctly without issues.","title":"Download &amp; Installation"},{"location":"guides/install/Quick-Start-Guide-for-Bukkit/#setting-up-a-world","text":"Here we will be replacing the server's default world with new world configured through the Bukkit config to use Terra as the new generator. Because we are working with changes to worlds ensure that you have made the necessary backups before making any destructive changes ! We do not recommend changing the generator of an existing world , as this will produce broken chunk borders between old and new terrain. If you would like to use a world manager like Multiverse Core to create a world instead of manually setting it as outlined here, please refer to Creating a Terra World .","title":"Setting up a World"},{"location":"guides/install/Quick-Start-Guide-for-Bukkit/#procedure","text":"Ensure your server is not running. If you missed it above, please make a backup of any relevant world folders in your server directory. If you're using a fresh server you won't need to worry about this ! Configure your server's world to use the new config as a generator: Navigate to the bukkit.yml file which is also contained within your server directory, and open it with any text editor. Assign your new generator to the default world by adding the following lines to the end of the file : worlds : <LEVEL NAME> : # The name of this can be found in the 'server.properties' file under # the 'level-name' key. By default, level-name is set to 'world'. generator : Terra:DEFAULT Either delete the existing world folder (the name of this folder is covered above) in your server directory, or rename it to something else (for example world_backup ). Boot your server back up. Your server should re-generate the world folder during startup Join your server and check if your new world is using Terra world generation. If you followed the steps correctly without any errors, then you have successfully set up a server with Terra!","title":"Procedure"},{"location":"guides/install/Quick-Start-Guide-for-Bukkit/#where-can-i-go-from-here","text":"If you would like to continue learning more about Terra, or would like to see what else you can get out of it, please continue on to the Config Packs page!","title":"Where can I go from here?"},{"location":"guides/install/Quick-Start-Guide-for-Fabric/","text":"This guide is intended for the Fabric version of Terra. See the Getting Started Page for guides on other platforms. If you have already installed Terra or already know how to install Fabric mods, you can skip to Setting up a World on a Fabric client or Setting up a World on a Fabric server . Download & Installation for a Fabric client \u00b6 Download the latest Terra Fabric release from the Modrinth website here . Once you have downloaded the .jar file from Modrinth, simply place the file into your mods folder located inside your Minecraft directory. Make sure you grab the correct version! Don't get the file named forge, or the file listed for a different minecraft version Once the mod has been installed, start your client. Once minecraft has loaded, check your logs for the following line to ensure everything has been installed correctly: [XX:XX:XX] [main/INFO]: Loaded config pack \"DEFAULT\" vX.X.X by dfsek in XXXX.XXms. This means that the mod has loaded successfully, and that the default Configuration Pack has been unpacked and loaded correctly without issues. TROUBLESHOOTING INSTALLATION \u00b6 If the mod, or DEFAULT pack failed to load, console/logs will display an error message outlining what went wrong. Be sure to read through the error and double check if you have made a mistake anywhere. If you are unable to install the mod successfully, and have attempted to fix any issues yourself, please feel free to shoot us a message on our Discord server and provide any relevant error logs! Setting up a World on a Fabric client \u00b6 Here we will be creating a new world with Terra generation. Procedure \u00b6 Create a new world just like normal, change the settings to your liking. But don't click \"Create New World\" yet \"Go to More World Options\" Press the \"World Type\" button untill you see \"World Type Terra: \", to use the default pack select \"Terra:DEFAULT\" Press \"Create New World\" and check if your new world is using Terra world generation. If you followed the steps correctly without any errors, then you have successfully set up a server with Terra! TROUBLESHOOTING WORLD SETUP \u00b6 In the case that you run into issues during the world set up process, be sure to check you have followed each step correctly. Check for any errors in console and try to interpret what the issue might be. Again you are unable to set up a world successfully, and have attempted to fix any issues yourself, please feel free to shoot us a message on our Discord server and provide any relevant information and or full server logs! Download & Installation for a Fabric server \u00b6 Download the latest Terra Fabric release from the Modrinth website here . Once you have downloaded the .jar file from Modrinth, simply place the file into your mods folder located inside your server root. Make sure you grab the correct version! Don't get the file named forge, or the file listed for a different minecraft version Once the mod has been installed, start your server. Once the the server has restarted, check your console log for the following line to ensure everything has been installed correctly: [XX:XX:XX] [main/INFO]: Loaded config pack \"DEFAULT\" vX.X.X by dfsek in XXXX.XXms. This means that the mod has loaded successfully, and that the default Configuration Pack has been unpacked and loaded correctly without issues. TROUBLESHOOTING INSTALLATION \u00b6 If the mod, or DEFAULT pack failed to load, the logs will display an error message outlining what went wrong. Be sure to read through the error and double check if you have made a mistake anywhere. If you are unable to install the mod successfully, and have attempted to fix any issues yourself, please feel free to shoot us a message on our Discord server and provide any relevant error logs! Setting up a World on a Fabric server \u00b6 Here we will be replacing the server's default world with a new Terra world. Because we are working with changes to worlds ensure that you have made the necessary backups before making any destructive changes ! It is not possible to easily change the generator of an existing world , this is a good thing, as this will produce broken chunk borders between old and new terrain. Procedure \u00b6 Ensure your server is not running. If you missed it above, please make a backup of any relevant world folders in your server directory. If you're using a fresh server you won't need to worry about this ! Configure your server's world to use the new config as a generator: Navigate to the server.properties file which is also contained within your server directory, and open it with any text editor. Assign your new generator to the default world by setting level-type to \"Terra: \" (for the default pack this would be \"Terra:DEFAULT\") note that the config ID is case sensitive! If the \"level-type\" key doesn't exist, simply add it yourself. Either delete the existing world folder in your server directory or rename it to something else (for example world_backup ). The name of your world can be found under the 'level-name' key, also in server.properties. The default world name is 'world'. Boot your server back up. Your server should re-generate the world folder during startup Join your server and check if your new world is using Terra world generation. If you followed the steps correctly without any errors, then you have successfully set up a server with Terra! Where can I go from here? \u00b6 If you would like to continue learning more about Terra, or would like to see what else you can get out of it, please continue on to the Config Packs page!","title":"Quick Start Guide for Fabric"},{"location":"guides/install/Quick-Start-Guide-for-Fabric/#download-installation-for-a-fabric-client","text":"Download the latest Terra Fabric release from the Modrinth website here . Once you have downloaded the .jar file from Modrinth, simply place the file into your mods folder located inside your Minecraft directory. Make sure you grab the correct version! Don't get the file named forge, or the file listed for a different minecraft version Once the mod has been installed, start your client. Once minecraft has loaded, check your logs for the following line to ensure everything has been installed correctly: [XX:XX:XX] [main/INFO]: Loaded config pack \"DEFAULT\" vX.X.X by dfsek in XXXX.XXms. This means that the mod has loaded successfully, and that the default Configuration Pack has been unpacked and loaded correctly without issues.","title":"Download &amp; Installation for a Fabric client"},{"location":"guides/install/Quick-Start-Guide-for-Fabric/#setting-up-a-world-on-a-fabric-client","text":"Here we will be creating a new world with Terra generation.","title":"Setting up a World on a Fabric client"},{"location":"guides/install/Quick-Start-Guide-for-Fabric/#procedure","text":"Create a new world just like normal, change the settings to your liking. But don't click \"Create New World\" yet \"Go to More World Options\" Press the \"World Type\" button untill you see \"World Type Terra: \", to use the default pack select \"Terra:DEFAULT\" Press \"Create New World\" and check if your new world is using Terra world generation. If you followed the steps correctly without any errors, then you have successfully set up a server with Terra!","title":"Procedure"},{"location":"guides/install/Quick-Start-Guide-for-Fabric/#download-installation-for-a-fabric-server","text":"Download the latest Terra Fabric release from the Modrinth website here . Once you have downloaded the .jar file from Modrinth, simply place the file into your mods folder located inside your server root. Make sure you grab the correct version! Don't get the file named forge, or the file listed for a different minecraft version Once the mod has been installed, start your server. Once the the server has restarted, check your console log for the following line to ensure everything has been installed correctly: [XX:XX:XX] [main/INFO]: Loaded config pack \"DEFAULT\" vX.X.X by dfsek in XXXX.XXms. This means that the mod has loaded successfully, and that the default Configuration Pack has been unpacked and loaded correctly without issues.","title":"Download &amp; Installation for a Fabric server"},{"location":"guides/install/Quick-Start-Guide-for-Fabric/#setting-up-a-world-on-a-fabric-server","text":"Here we will be replacing the server's default world with a new Terra world. Because we are working with changes to worlds ensure that you have made the necessary backups before making any destructive changes ! It is not possible to easily change the generator of an existing world , this is a good thing, as this will produce broken chunk borders between old and new terrain.","title":"Setting up a World on a Fabric server"},{"location":"guides/install/Quick-Start-Guide-for-Fabric/#procedure_1","text":"Ensure your server is not running. If you missed it above, please make a backup of any relevant world folders in your server directory. If you're using a fresh server you won't need to worry about this ! Configure your server's world to use the new config as a generator: Navigate to the server.properties file which is also contained within your server directory, and open it with any text editor. Assign your new generator to the default world by setting level-type to \"Terra: \" (for the default pack this would be \"Terra:DEFAULT\") note that the config ID is case sensitive! If the \"level-type\" key doesn't exist, simply add it yourself. Either delete the existing world folder in your server directory or rename it to something else (for example world_backup ). The name of your world can be found under the 'level-name' key, also in server.properties. The default world name is 'world'. Boot your server back up. Your server should re-generate the world folder during startup Join your server and check if your new world is using Terra world generation. If you followed the steps correctly without any errors, then you have successfully set up a server with Terra!","title":"Procedure"},{"location":"guides/install/Quick-Start-Guide-for-Fabric/#where-can-i-go-from-here","text":"If you would like to continue learning more about Terra, or would like to see what else you can get out of it, please continue on to the Config Packs page!","title":"Where can I go from here?"},{"location":"guides/install/Quick-Start-Guide-for-Forge/","text":"This guide is intended for the Forge version of Terra. See the Getting Started Page for guides on other platforms. The forge version is alpha software, for a more stable experience the Fabric version is recommended \u26a0\ufe0f If you have already installed Terra or already know how to install Forge mods, you can skip to Setting up a World on a Forge client or Setting up a World on a Forge server . Download & Installation for a Forge client \u00b6 Download the latest Terra Forge release from the Modrinth website here . Once you have downloaded the .jar file from Modrinth, simply place the file into your mods folder located inside your Minecraft directory. Make sure you grab the correct version! Don't get a file with \"fabric\" in the filename, or the file listed for a different minecraft version Once the mod has been installed, start your client. Once minecraft has loaded, check your logs for the following line to ensure everything has been installed correctly: [XX:XX:XX] [main/INFO]: Loaded config pack \"DEFAULT\" vX.X.X by dfsek in XXXX.XXms. This means that the mod has loaded successfully, and that the default Configuration Pack has been unpacked and loaded correctly without issues. TROUBLESHOOTING INSTALLATION \u00b6 If the mod, or DEFAULT pack failed to load, console/logs will display an error message outlining what went wrong. Be sure to read through the error and double check if you have made a mistake anywhere. If you are unable to install the mod successfully, and have attempted to fix any issues yourself, please feel free to shoot us a message on our Discord server and provide any relevant error logs! Setting up a World on a Forge client \u00b6 Here we will be creating a new world with Terra generation. Procedure \u00b6 Create a new world just like normal, change the settings to your liking. But don't click \"Create New World\" yet \"Go to More World Options\" Press the \"World Type\" button untill you see \"World Type Terra: \", to use the default pack select \"Terra:DEFAULT\" Press \"Create New World\" and check if your new world is using Terra world generation. If you followed the steps correctly without any errors, then you have successfully set up a server with Terra! TROUBLESHOOTING WORLD SETUP \u00b6 In the case that you run into issues during the world set up process, be sure to check you have followed each step correctly. Check for any errors in console and try to interpret what the issue might be. Again you are unable to set up a world successfully, and have attempted to fix any issues yourself, please feel free to shoot us a message on our Discord server and provide any relevant information and or full server logs! Download & Installation for a Forge server \u00b6 Download the latest Terra Forge release from the Modrinth website here . Once you have downloaded the .jar file from Modrinth, simply place the file into your mods folder located inside your server root. Make sure you grab the correct version! Don't get a file with \"fabric\" in the filename, or the file listed for a different minecraft version Once the mod has been installed, start your server. Once the the server has restarted, check your console log for the following line to ensure everything has been installed correctly: [XX:XX:XX] [main/INFO]: Loaded config pack \"DEFAULT\" vX.X.X by dfsek in XXXX.XXms. This means that the mod has loaded successfully, and that the default Configuration Pack has been unpacked and loaded correctly without issues. TROUBLESHOOTING INSTALLATION \u00b6 If the mod, or DEFAULT pack failed to load, the logs will display an error message outlining what went wrong. Be sure to read through the error and double check if you have made a mistake anywhere. If you are unable to install the mod successfully, and have attempted to fix any issues yourself, please feel free to shoot us a message on our Discord server and provide any relevant error logs! Setting up a World on a Forge server \u00b6 Here we will be replacing the server's default world with a new Terra world. Because we are working with changes to worlds ensure that you have made the necessary backups before making any destructive changes ! It is not possible to easily change the generator of an existing world , this is a good thing, as this will produce broken chunk borders between old and new terrain. Procedure \u00b6 Ensure your server is not running. If you missed it above, please make a backup of any relevant world folders in your server directory. If you're using a fresh server you won't need to worry about this ! Configure your server's world to use the new config as a generator: Navigate to the server.properties file which is also contained within your server directory, and open it with any text editor. Assign your new generator to the default world by setting level-type to \"Terra: \" (for the default pack this would be \"Terra:DEFAULT\") note that the config ID is case sensitive! If the \"level-type\" key doesn't exist, simply add it yourself. Either delete the existing world folder in your server directory or rename it to something else (for example world_backup ). The name of your world can be found under the 'level-name' key, also in server.properties. The default world name is 'world'. Boot your server back up. Your server should re-generate the world folder during startup Join your server and check if your new world is using Terra world generation. If you followed the steps correctly without any errors, then you have successfully set up a server with Terra! Where can I go from here? \u00b6 If you would like to continue learning more about Terra, or would like to see what else you can get out of it, please continue on to the Config Packs page!","title":"Quick Start Guide for Forge"},{"location":"guides/install/Quick-Start-Guide-for-Forge/#download-installation-for-a-forge-client","text":"Download the latest Terra Forge release from the Modrinth website here . Once you have downloaded the .jar file from Modrinth, simply place the file into your mods folder located inside your Minecraft directory. Make sure you grab the correct version! Don't get a file with \"fabric\" in the filename, or the file listed for a different minecraft version Once the mod has been installed, start your client. Once minecraft has loaded, check your logs for the following line to ensure everything has been installed correctly: [XX:XX:XX] [main/INFO]: Loaded config pack \"DEFAULT\" vX.X.X by dfsek in XXXX.XXms. This means that the mod has loaded successfully, and that the default Configuration Pack has been unpacked and loaded correctly without issues.","title":"Download &amp; Installation for a Forge client"},{"location":"guides/install/Quick-Start-Guide-for-Forge/#setting-up-a-world-on-a-forge-client","text":"Here we will be creating a new world with Terra generation.","title":"Setting up a World on a Forge client"},{"location":"guides/install/Quick-Start-Guide-for-Forge/#procedure","text":"Create a new world just like normal, change the settings to your liking. But don't click \"Create New World\" yet \"Go to More World Options\" Press the \"World Type\" button untill you see \"World Type Terra: \", to use the default pack select \"Terra:DEFAULT\" Press \"Create New World\" and check if your new world is using Terra world generation. If you followed the steps correctly without any errors, then you have successfully set up a server with Terra!","title":"Procedure"},{"location":"guides/install/Quick-Start-Guide-for-Forge/#download-installation-for-a-forge-server","text":"Download the latest Terra Forge release from the Modrinth website here . Once you have downloaded the .jar file from Modrinth, simply place the file into your mods folder located inside your server root. Make sure you grab the correct version! Don't get a file with \"fabric\" in the filename, or the file listed for a different minecraft version Once the mod has been installed, start your server. Once the the server has restarted, check your console log for the following line to ensure everything has been installed correctly: [XX:XX:XX] [main/INFO]: Loaded config pack \"DEFAULT\" vX.X.X by dfsek in XXXX.XXms. This means that the mod has loaded successfully, and that the default Configuration Pack has been unpacked and loaded correctly without issues.","title":"Download &amp; Installation for a Forge server"},{"location":"guides/install/Quick-Start-Guide-for-Forge/#setting-up-a-world-on-a-forge-server","text":"Here we will be replacing the server's default world with a new Terra world. Because we are working with changes to worlds ensure that you have made the necessary backups before making any destructive changes ! It is not possible to easily change the generator of an existing world , this is a good thing, as this will produce broken chunk borders between old and new terrain.","title":"Setting up a World on a Forge server"},{"location":"guides/install/Quick-Start-Guide-for-Forge/#procedure_1","text":"Ensure your server is not running. If you missed it above, please make a backup of any relevant world folders in your server directory. If you're using a fresh server you won't need to worry about this ! Configure your server's world to use the new config as a generator: Navigate to the server.properties file which is also contained within your server directory, and open it with any text editor. Assign your new generator to the default world by setting level-type to \"Terra: \" (for the default pack this would be \"Terra:DEFAULT\") note that the config ID is case sensitive! If the \"level-type\" key doesn't exist, simply add it yourself. Either delete the existing world folder in your server directory or rename it to something else (for example world_backup ). The name of your world can be found under the 'level-name' key, also in server.properties. The default world name is 'world'. Boot your server back up. Your server should re-generate the world folder during startup Join your server and check if your new world is using Terra world generation. If you followed the steps correctly without any errors, then you have successfully set up a server with Terra!","title":"Procedure"},{"location":"guides/install/Quick-Start-Guide-for-Forge/#where-can-i-go-from-here","text":"If you would like to continue learning more about Terra, or would like to see what else you can get out of it, please continue on to the Config Packs page!","title":"Where can I go from here?"},{"location":"packs/","text":"test","title":"Pack Documentation"},{"location":"packs/config-files/Biome-Configuration/","text":"This page discusses the configuration of Biomes. Biome configurations are in the biomes/ directory within a config pack. Object Options \u00b6 Biomes support all Terra Object Options . Main options \u00b6 tags \u00b6 A list of tags to be used in Biome Pipeline selection. Tags may be any string, and a biome may have any number of tags. color \u00b6 An integer representation of a color to be used in image selection. Example: 0xffffff = white. noise-equation \u00b6 Noise equation to generate terrain with. Positive values produce solid terrain, negative values produce negative terrain. Variables and functions: * x - Current x-coordinate * y - Current y-coordinate * z - Current z-coordinate * All defined noise functions can be accessed via their ID. * Terra includes most standard mathematical functions (trig functions, max(a, b) , min(a, b) , floor(x) , ceil(x) , round(x) , etc.) If you want another function implemented, submit a PR to Paralithic (our expression evaluator), or create an issue requesting it. More info about setting up equations here . This value must be included, and can be abstracted. vanilla \u00b6 The ID of the Vanilla biome to use for this custom biome. A list of IDs can be found here . Subsections \u00b6 structures \u00b6 A list of structure config IDs that can generate in this biome. This value is optional (defaults to an empty list) and can be abstracted. palette \u00b6 A list of Palettes to use in the biome. Each list entry contains a single key-value pair, with the key being the palette ID, and the value being the Y-level at which the palette starts to generate. A shortcut exists for palettes that only contain a single block. Instead of creating a palette file for a single-block palette, you may simply include BLOCK:minecraft:block_id as a palette ID in this list. This value must be included, and can be abstracted. Example Palette Configuration palette : - \"BLOCK:minecraft:bedrock\" : 0 - GRASSY : 255 This palette configuration generates the `GRASSY` palette at Y level 255 and down, until it reaches Y=0, where a single-block palette containing just Bedrock will be generated. flora \u00b6 A list of Flora layers to generate in this biome. Terra generates these layers one by one, meaning you can stack multiple layers on top of each other. Various options that define the Flora to generate in this biome. This value must be included, and can be abstracted. Layer Options: \u00b6 density - The chance (per 100) each block will attempt to generate Flora. This value may be a decimal. distribution - Noise Configuration defining flora placement. Defaults to 2D white noise. If this value is zero, or if it is not included, a random distribution will be used instead. items - Contains a weighted pool of Flora items to generate in this layer. Key = flora ID, value = weight. IDs may be from pre-included flora, or custom flora. y - Height restrictions for this Flora object. min - The minimum height at which this Flora object can generate. max - The maximum height at which this Flora object can generate. You may include as many layers as you want in your biomes, they will generate sequentially. Example Flora Configuration flora : - density : 100 simplex-frequency : 0.1 items : - BLANK : 7 - LEAVES : 3 y : min : 62 max : 180 - density : 50 items : - TALL_GRASS : 3 - GRASS : 7 - SMALL_ROCK : 1 y : min : 62 max : 180 This example config generates 2 layers of flora, one with a simplex distribution of `LEAVES` and `BLANK`, the other with a random distribution of `TALL_GRASS`, `GRASS`, and `SMALL_ROCK`. trees \u00b6 A list of tree layers to include in this biome. Layer Options \u00b6 density - The chance (per 100) every fourth block will attempt to generate a Tree. This value may be a decimal. (Since this value is every fourth block, it can be thought of as out of 400). distribution - Noise Configuration defining tree placement. Defaults to 2D white noise. items - Contains a weighted pool of Tree items to generate in this layer. Key = tree ID, value = weight. IDs may be from pre-included flora, or custom flora. y - Height restrictions for this Tree object. min - The minimum height at which this Tree object can generate. max - The maximum height at which this Tree object can generate. Example Tree Configuration - density : 10 items : - OAK : 1 y : min : 58 max : 84 A standard Tree configuration, potentially useful for a forest. It generates `OAK` trees. All Tree items have the same height restrictions; they can only generate from Y levels 58 to 84. carving \u00b6 Options for Carvers in this biome. This option contains key-value pairs. The key is a Carver ID, and the value is tha chance per chunk that carver will spawn in a chunk. Carvers aren't stored in a weighted pool , Each carver uses an independent calculation, therefore multiple carvers may spawn in the same chunk! Example Carver Configuration carving : CAVE : 30 RAVINE : 5 CAVERN : 5 This configuration defined 3 Carvers in this biome: * `CAVE` with a 30% chance of spawning per chunk. * `RAVINE` with a 5% chance of spawning per chunk. * `CAVERN` with a 5% chance of spawning per chunk. ores \u00b6 A set of entries that each define an Ore object to generate, how much of it to generate, and the maximum and minimum Y-levels at which veins may generate. Options: * ORE_ID - The ID of the Ore object to generate. * min - The minimum number of veins to generate per chunk. * max - The maximum number of veins to generate per chunk. * min-y - The minimum Y-level at which veins may begin. * max-y - The maximum Y-level at which veins may begin. Example Ore Configuration ores : DIRT : min : 0 max : 1 min-height : 0 max-height : 84 GRAVEL : min : 0 max : 1 min-height : 0 max-height : 84 DIORITE : min : 0 max : 1 min-height : 0 max-height : 84 ANDESITE : min : 0 max : 1 min-height : 0 max-height : 84 GRANITE : min : 0 max : 1 min-height : 0 max-height : 84 COAL_ORE : min : 4 max : 8 min-height : 0 max-height : 84 IRON_ORE : min : 2 max : 6 min-height : 0 max-height : 64 GOLD_ORE : min : 1 max : 3 min-height : 0 max-height : 32 LAPIS_ORE : min : 1 max : 2 min-height : 0 max-height : 32 REDSTONE_ORE : min : 1 max : 2 min-height : 0 max-height : 16 DIAMOND_ORE : min : 1 max : 1 min-height : 0 max-height : 16 This configuration is a classic, it defines several \"deposits\" (Dirt, Gravel, Diorite, Andesite, Granite), as well as all Vanilla ores, at standard Y-levels and chances. This example assumes that [Ore configs](./Ore-Configuration) with the corresponding IDs have been set up. Super-Secret Advanced Options \u00b6 These options are for advanced users that wish to have more control over biomes. ocean \u00b6 Options for the ocean in this biome. * level - Y-value at which to generate oceans. Ocean will be generated at locations that would be air, and are below this Y-value. Defaults to 62. * palette - Palette to generate Ocean with. Defaults to a single-block palette containing Water. slant \u00b6 Options for slant palettes in this biome. A slant palette is a separate palette that is inserted into steep/slanted locations. It allows for custom blocks to be defined on cliffsides. * palette A map of palettes for different Y-levels. Follows the same structure as the main palette configuration . These palettes will be inserted into locations that are \"slanted\". * y-offset - The distance to check vertically for blocks. * top - The distance to check upwards for blocks. Higher values allow the normal palette to take over on top of steep ledges. * bottom - The distance to check downwards for blocks. Higher values allow the normal palette to take over under steep overhangs. elevation \u00b6 Options for the \"elevation\" feature, used to raise/lower areas in high resolution. * equation - The elevation equation to use. The elevation equation is very similar to the noise equation, except it is 2-dimensional. This means that only x and z exist as variables, and only noise2 is available as a function. The standard noise equation receives the current Y-value, plus the result of this equation during generation, so the elevation equation raises/lowers the terrain height based on its value for any x/z coordinate pair. * weight - Weight of this biome's elevation equation. Higher weights take priority during elevation blending. blend \u00b6 Per-biome blending options * distance - Distance to use for blending. Higher distance = more blending. Actual distance = distance*step. By default, this is 4. * step - Step for sampling blend points. Higher values = lower resolution blending. By default, this is 4. * weight - Weight of this biome. Higher weights take priority during blending. variables \u00b6 Identical to the variables option in pack.yml . These may be used to define custom variables per-biome, or to override variables per-biome. functions \u00b6 Identical to the functions option in pack.yml . These may be used to define custom functions per-biome, or to override functions per-biome.","title":"Config files"},{"location":"packs/config-files/Biome-Configuration/#object-options","text":"Biomes support all Terra Object Options .","title":"Object Options"},{"location":"packs/config-files/Biome-Configuration/#main-options","text":"","title":"Main options"},{"location":"packs/config-files/Biome-Configuration/#tags","text":"A list of tags to be used in Biome Pipeline selection. Tags may be any string, and a biome may have any number of tags.","title":"tags"},{"location":"packs/config-files/Biome-Configuration/#color","text":"An integer representation of a color to be used in image selection. Example: 0xffffff = white.","title":"color"},{"location":"packs/config-files/Biome-Configuration/#noise-equation","text":"Noise equation to generate terrain with. Positive values produce solid terrain, negative values produce negative terrain. Variables and functions: * x - Current x-coordinate * y - Current y-coordinate * z - Current z-coordinate * All defined noise functions can be accessed via their ID. * Terra includes most standard mathematical functions (trig functions, max(a, b) , min(a, b) , floor(x) , ceil(x) , round(x) , etc.) If you want another function implemented, submit a PR to Paralithic (our expression evaluator), or create an issue requesting it. More info about setting up equations here . This value must be included, and can be abstracted.","title":"noise-equation"},{"location":"packs/config-files/Biome-Configuration/#vanilla","text":"The ID of the Vanilla biome to use for this custom biome. A list of IDs can be found here .","title":"vanilla"},{"location":"packs/config-files/Biome-Configuration/#subsections","text":"","title":"Subsections"},{"location":"packs/config-files/Biome-Configuration/#structures","text":"A list of structure config IDs that can generate in this biome. This value is optional (defaults to an empty list) and can be abstracted.","title":"structures"},{"location":"packs/config-files/Biome-Configuration/#palette","text":"A list of Palettes to use in the biome. Each list entry contains a single key-value pair, with the key being the palette ID, and the value being the Y-level at which the palette starts to generate. A shortcut exists for palettes that only contain a single block. Instead of creating a palette file for a single-block palette, you may simply include BLOCK:minecraft:block_id as a palette ID in this list. This value must be included, and can be abstracted. Example Palette Configuration palette : - \"BLOCK:minecraft:bedrock\" : 0 - GRASSY : 255 This palette configuration generates the `GRASSY` palette at Y level 255 and down, until it reaches Y=0, where a single-block palette containing just Bedrock will be generated.","title":"palette"},{"location":"packs/config-files/Biome-Configuration/#flora","text":"A list of Flora layers to generate in this biome. Terra generates these layers one by one, meaning you can stack multiple layers on top of each other. Various options that define the Flora to generate in this biome. This value must be included, and can be abstracted.","title":"flora"},{"location":"packs/config-files/Biome-Configuration/#layer-options","text":"density - The chance (per 100) each block will attempt to generate Flora. This value may be a decimal. distribution - Noise Configuration defining flora placement. Defaults to 2D white noise. If this value is zero, or if it is not included, a random distribution will be used instead. items - Contains a weighted pool of Flora items to generate in this layer. Key = flora ID, value = weight. IDs may be from pre-included flora, or custom flora. y - Height restrictions for this Flora object. min - The minimum height at which this Flora object can generate. max - The maximum height at which this Flora object can generate. You may include as many layers as you want in your biomes, they will generate sequentially. Example Flora Configuration flora : - density : 100 simplex-frequency : 0.1 items : - BLANK : 7 - LEAVES : 3 y : min : 62 max : 180 - density : 50 items : - TALL_GRASS : 3 - GRASS : 7 - SMALL_ROCK : 1 y : min : 62 max : 180 This example config generates 2 layers of flora, one with a simplex distribution of `LEAVES` and `BLANK`, the other with a random distribution of `TALL_GRASS`, `GRASS`, and `SMALL_ROCK`.","title":"Layer Options:"},{"location":"packs/config-files/Biome-Configuration/#trees","text":"A list of tree layers to include in this biome.","title":"trees"},{"location":"packs/config-files/Biome-Configuration/#layer-options_1","text":"density - The chance (per 100) every fourth block will attempt to generate a Tree. This value may be a decimal. (Since this value is every fourth block, it can be thought of as out of 400). distribution - Noise Configuration defining tree placement. Defaults to 2D white noise. items - Contains a weighted pool of Tree items to generate in this layer. Key = tree ID, value = weight. IDs may be from pre-included flora, or custom flora. y - Height restrictions for this Tree object. min - The minimum height at which this Tree object can generate. max - The maximum height at which this Tree object can generate. Example Tree Configuration - density : 10 items : - OAK : 1 y : min : 58 max : 84 A standard Tree configuration, potentially useful for a forest. It generates `OAK` trees. All Tree items have the same height restrictions; they can only generate from Y levels 58 to 84.","title":"Layer Options"},{"location":"packs/config-files/Biome-Configuration/#carving","text":"Options for Carvers in this biome. This option contains key-value pairs. The key is a Carver ID, and the value is tha chance per chunk that carver will spawn in a chunk. Carvers aren't stored in a weighted pool , Each carver uses an independent calculation, therefore multiple carvers may spawn in the same chunk! Example Carver Configuration carving : CAVE : 30 RAVINE : 5 CAVERN : 5 This configuration defined 3 Carvers in this biome: * `CAVE` with a 30% chance of spawning per chunk. * `RAVINE` with a 5% chance of spawning per chunk. * `CAVERN` with a 5% chance of spawning per chunk.","title":"carving"},{"location":"packs/config-files/Biome-Configuration/#ores","text":"A set of entries that each define an Ore object to generate, how much of it to generate, and the maximum and minimum Y-levels at which veins may generate. Options: * ORE_ID - The ID of the Ore object to generate. * min - The minimum number of veins to generate per chunk. * max - The maximum number of veins to generate per chunk. * min-y - The minimum Y-level at which veins may begin. * max-y - The maximum Y-level at which veins may begin. Example Ore Configuration ores : DIRT : min : 0 max : 1 min-height : 0 max-height : 84 GRAVEL : min : 0 max : 1 min-height : 0 max-height : 84 DIORITE : min : 0 max : 1 min-height : 0 max-height : 84 ANDESITE : min : 0 max : 1 min-height : 0 max-height : 84 GRANITE : min : 0 max : 1 min-height : 0 max-height : 84 COAL_ORE : min : 4 max : 8 min-height : 0 max-height : 84 IRON_ORE : min : 2 max : 6 min-height : 0 max-height : 64 GOLD_ORE : min : 1 max : 3 min-height : 0 max-height : 32 LAPIS_ORE : min : 1 max : 2 min-height : 0 max-height : 32 REDSTONE_ORE : min : 1 max : 2 min-height : 0 max-height : 16 DIAMOND_ORE : min : 1 max : 1 min-height : 0 max-height : 16 This configuration is a classic, it defines several \"deposits\" (Dirt, Gravel, Diorite, Andesite, Granite), as well as all Vanilla ores, at standard Y-levels and chances. This example assumes that [Ore configs](./Ore-Configuration) with the corresponding IDs have been set up.","title":"ores"},{"location":"packs/config-files/Biome-Configuration/#super-secret-advanced-options","text":"These options are for advanced users that wish to have more control over biomes.","title":"Super-Secret Advanced Options"},{"location":"packs/config-files/Biome-Configuration/#ocean","text":"Options for the ocean in this biome. * level - Y-value at which to generate oceans. Ocean will be generated at locations that would be air, and are below this Y-value. Defaults to 62. * palette - Palette to generate Ocean with. Defaults to a single-block palette containing Water.","title":"ocean"},{"location":"packs/config-files/Biome-Configuration/#slant","text":"Options for slant palettes in this biome. A slant palette is a separate palette that is inserted into steep/slanted locations. It allows for custom blocks to be defined on cliffsides. * palette A map of palettes for different Y-levels. Follows the same structure as the main palette configuration . These palettes will be inserted into locations that are \"slanted\". * y-offset - The distance to check vertically for blocks. * top - The distance to check upwards for blocks. Higher values allow the normal palette to take over on top of steep ledges. * bottom - The distance to check downwards for blocks. Higher values allow the normal palette to take over under steep overhangs.","title":"slant"},{"location":"packs/config-files/Biome-Configuration/#elevation","text":"Options for the \"elevation\" feature, used to raise/lower areas in high resolution. * equation - The elevation equation to use. The elevation equation is very similar to the noise equation, except it is 2-dimensional. This means that only x and z exist as variables, and only noise2 is available as a function. The standard noise equation receives the current Y-value, plus the result of this equation during generation, so the elevation equation raises/lowers the terrain height based on its value for any x/z coordinate pair. * weight - Weight of this biome's elevation equation. Higher weights take priority during elevation blending.","title":"elevation"},{"location":"packs/config-files/Biome-Configuration/#blend","text":"Per-biome blending options * distance - Distance to use for blending. Higher distance = more blending. Actual distance = distance*step. By default, this is 4. * step - Step for sampling blend points. Higher values = lower resolution blending. By default, this is 4. * weight - Weight of this biome. Higher weights take priority during blending.","title":"blend"},{"location":"packs/config-files/Biome-Configuration/#variables","text":"Identical to the variables option in pack.yml . These may be used to define custom variables per-biome, or to override variables per-biome.","title":"variables"},{"location":"packs/config-files/Biome-Configuration/#functions","text":"Identical to the functions option in pack.yml . These may be used to define custom functions per-biome, or to override functions per-biome.","title":"functions"},{"location":"packs/config-files/Carver-Configuration/","text":"Carver configurations are in the carving/ directory within a config pack. Carvers \"carve\" out sections of a world after generation. They are typically used to create caves and ravines. A carver is essentially an ellipse. This ellipse then moves around the world on a randomly determined path (called a worm), carving out where it moves. Object Options \u00b6 Carvers support all Terra Object Options . Options \u00b6 length \u00b6 The minimum and maximum length of the cave. * min - The minimum length of the cave. * max - The maximum length of the cave. step \u00b6 How many blocks the worm should move each step. Example: a value of 2 would cause the worm to move 2 blocks between each carving. Defaults to 2. start \u00b6 Configuration for how the carver begins. * x - The multiplier for the initial vector X-component. (Higher values cause carving to begin horizontally more often). * y - The multiplier for the initial vector Y-component. (Higher values cause carving to begin vertically more often). * z - The multiplier for the initial vector Z-component. (Higher values cause carving to begin horizontally more often). * radius - Configuration for the radius. * x - X radius equation. * y - Y radius equation. * z - Z radius equation. * height - Minimum and maximumY-levels at which the carver is able to begin. * min - Minimum Y-level at which the carver can begin. * max - Maximum Y-level at which the carver can begin. Radius Equations \u00b6 The X, Y, and Z radius equations are mathematical expressions to be evaluated at each carving step. 2 variables are provided to these expressions: * length - The total length of the current worm. * position - The carver's current position. (position = 0 at the beginning of carving, position = length at the end). cut \u00b6 Options to \"cut off\" the topmost/bottommost parts of the carved area. This can be used to give your carvings flat floors/ceilings. * top - Number of blocks to cut off the top of carving. * bottom - Number of blocks to cut off the bottom of carving. mutate \u00b6 How to mutate the carver as it progresses. * x - X-Axis rotation multiplier (rotating around the X-Axis will cause the carver to turn up/down, therefore increasing this value will cause carving to generally be more vertical). * y - Y-Axis rotation multiplier (rotating around the Y-Axis will cause the carver to turn left/right, therefore increasing this value will cause carving to generally be more horizontal). * z - Z-Axis rotation multiplier (rotating around the X-Axis will cause the carver to turn up/down, therefore increasing this value will cause carving to generally be more vertical). * radius - Radius multiplier. Increasing this value will cause more variations in the carver's radius during carving. shift \u00b6 A list of blocks to shift downwards when carved. List elements should be formatted as: \"minecraft:block_id\" : # ID of block to pull downwards. - \"minecraft:other_block_1\" # Block that can be replaced - \"minecraft:other_block_2\" # More blocks that can be replaced... The most common use of this is definitely pulling Grass Blocks down into exposed dirt. shift : \"minecraft:grass_block\" : [ \"minecraft:dirt\" ] update \u00b6 A list of block IDs that should be updated during generation. **Do not include anything in this option unless you are pregenerating, as this option can be extremely laggy!) Example that prevents floating water in caves: update : - \"minecraft:water\" palette \u00b6 Options for cave floor, wall, ceiling, and center palettes. * inner - Palette on the inside of the carved area. * outer - Palette on the left/right walls of the carved areas. * top - Palette on the top of the carved area. * bottom - Palette on the bottom of the carved area. These are not standard palettes! Carver palettes must be defined in the carver file . Cave Palette Configuration \u00b6 Cave palettes hold more information than standard palettes, hence why they are kept separate. The config scheme outlined in this section is to be used in the palette keys in a Carver config. replace \u00b6 A list of block IDs that may be replaced by this palette. replace-blacklist \u00b6 Whether the materials in replace should be treated as a whitelist or blacklist. recalculate-direction \u00b6 How many blocks to continue before recalculating the worm's direction. * min - Minimum distance before recalculating. Defaults to 8. * max - Maximum distance before recalculating. Defaults to 12. layers \u00b6 Standard palette layer configuration (see Palette page) One key difference: The layers sub-option has been replaced with y . while layers defines how many layers to continue the palette layer, y defines the Y-level under which the layer generates.","title":"Carver Configuration"},{"location":"packs/config-files/Carver-Configuration/#object-options","text":"Carvers support all Terra Object Options .","title":"Object Options"},{"location":"packs/config-files/Carver-Configuration/#options","text":"","title":"Options"},{"location":"packs/config-files/Carver-Configuration/#length","text":"The minimum and maximum length of the cave. * min - The minimum length of the cave. * max - The maximum length of the cave.","title":"length"},{"location":"packs/config-files/Carver-Configuration/#step","text":"How many blocks the worm should move each step. Example: a value of 2 would cause the worm to move 2 blocks between each carving. Defaults to 2.","title":"step"},{"location":"packs/config-files/Carver-Configuration/#start","text":"Configuration for how the carver begins. * x - The multiplier for the initial vector X-component. (Higher values cause carving to begin horizontally more often). * y - The multiplier for the initial vector Y-component. (Higher values cause carving to begin vertically more often). * z - The multiplier for the initial vector Z-component. (Higher values cause carving to begin horizontally more often). * radius - Configuration for the radius. * x - X radius equation. * y - Y radius equation. * z - Z radius equation. * height - Minimum and maximumY-levels at which the carver is able to begin. * min - Minimum Y-level at which the carver can begin. * max - Maximum Y-level at which the carver can begin.","title":"start"},{"location":"packs/config-files/Carver-Configuration/#radius-equations","text":"The X, Y, and Z radius equations are mathematical expressions to be evaluated at each carving step. 2 variables are provided to these expressions: * length - The total length of the current worm. * position - The carver's current position. (position = 0 at the beginning of carving, position = length at the end).","title":"Radius Equations"},{"location":"packs/config-files/Carver-Configuration/#cut","text":"Options to \"cut off\" the topmost/bottommost parts of the carved area. This can be used to give your carvings flat floors/ceilings. * top - Number of blocks to cut off the top of carving. * bottom - Number of blocks to cut off the bottom of carving.","title":"cut"},{"location":"packs/config-files/Carver-Configuration/#mutate","text":"How to mutate the carver as it progresses. * x - X-Axis rotation multiplier (rotating around the X-Axis will cause the carver to turn up/down, therefore increasing this value will cause carving to generally be more vertical). * y - Y-Axis rotation multiplier (rotating around the Y-Axis will cause the carver to turn left/right, therefore increasing this value will cause carving to generally be more horizontal). * z - Z-Axis rotation multiplier (rotating around the X-Axis will cause the carver to turn up/down, therefore increasing this value will cause carving to generally be more vertical). * radius - Radius multiplier. Increasing this value will cause more variations in the carver's radius during carving.","title":"mutate"},{"location":"packs/config-files/Carver-Configuration/#shift","text":"A list of blocks to shift downwards when carved. List elements should be formatted as: \"minecraft:block_id\" : # ID of block to pull downwards. - \"minecraft:other_block_1\" # Block that can be replaced - \"minecraft:other_block_2\" # More blocks that can be replaced... The most common use of this is definitely pulling Grass Blocks down into exposed dirt. shift : \"minecraft:grass_block\" : [ \"minecraft:dirt\" ]","title":"shift"},{"location":"packs/config-files/Carver-Configuration/#update","text":"A list of block IDs that should be updated during generation. **Do not include anything in this option unless you are pregenerating, as this option can be extremely laggy!) Example that prevents floating water in caves: update : - \"minecraft:water\"","title":"update"},{"location":"packs/config-files/Carver-Configuration/#palette","text":"Options for cave floor, wall, ceiling, and center palettes. * inner - Palette on the inside of the carved area. * outer - Palette on the left/right walls of the carved areas. * top - Palette on the top of the carved area. * bottom - Palette on the bottom of the carved area. These are not standard palettes! Carver palettes must be defined in the carver file .","title":"palette"},{"location":"packs/config-files/Carver-Configuration/#cave-palette-configuration","text":"Cave palettes hold more information than standard palettes, hence why they are kept separate. The config scheme outlined in this section is to be used in the palette keys in a Carver config.","title":"Cave Palette Configuration"},{"location":"packs/config-files/Carver-Configuration/#replace","text":"A list of block IDs that may be replaced by this palette.","title":"replace"},{"location":"packs/config-files/Carver-Configuration/#replace-blacklist","text":"Whether the materials in replace should be treated as a whitelist or blacklist.","title":"replace-blacklist"},{"location":"packs/config-files/Carver-Configuration/#recalculate-direction","text":"How many blocks to continue before recalculating the worm's direction. * min - Minimum distance before recalculating. Defaults to 8. * max - Maximum distance before recalculating. Defaults to 12.","title":"recalculate-direction"},{"location":"packs/config-files/Carver-Configuration/#layers","text":"Standard palette layer configuration (see Palette page) One key difference: The layers sub-option has been replaced with y . while layers defines how many layers to continue the palette layer, y defines the Y-level under which the layer generates.","title":"layers"},{"location":"packs/config-files/Flora-Configuration/","text":"This page discusses the configuration of custom Flora objects. For information on included Flora, see the Included Flora page. Flora configurations are in the flora/ directory within a config pack. A Flora object is a small structure-like object that is 1xNx1 blocks in size (1x1 blocks wide, any number of blocks tall). For larger common custom structures (like trees/rocks), see Trees . For even larger, less common structures, like temples and monuments, see Structures . Object Options \u00b6 Flora supports all Terra Object Options . Options \u00b6 ceiling \u00b6 Whether this Flora object generates from the ceiling, or the floor. When true, the object will generate hanging from the ceiling. When false, the object will generate upwards from the floor. Note: This does not invert the layers (e.g. first layer will still be on the top, regardless of this option). This value is optional, and defaults false. spawnable \u00b6 A list of block IDs that this Flora object can spawn on. replaceable \u00b6 A list of block IDs that this Flora object can replace during generation. irrigable \u00b6 A list of blocks that must be bordering the block the Flora will be planted on for it to grow. This value is optional. It defaults to all blocks (allowing the Flora to grow on any spawnable block). rotatable \u00b6 A list of blocks that the flora item should be rotated to face. An example use case is sugarcane, where water would be the only item in this list, meaning sugarcane would only be able to grow bordering water. layers \u00b6 This option is identical to the layers option of a Block Palette , just interpreted differently. When generating Flora, each layer will be generated, starting with the topmost layer, and going downwards. Examples \u00b6 Example Flora (Tall Seagrass) layers : - materials : - \"minecraft:tall_seagrass[half=upper]\" : 1 layers : 1 - materials : - \"minecraft:tall_seagrass[half=lower]\" : 1 layers : 1 id : TALL_SEAGRASS name : \"Tall Sea Grass\" spawnable : - \"minecraft:sand\" - \"minecraft:stone\" - \"minecraft:red_sand\" - \"minecraft:gravel\" - \"minecraft:dirt\" replaceable : - \"minecraft:water\" This config will generate a 2-block Seagrass plant. The top layer of the palette is `tall_seagrass`, set to the upper half variant. The second (bottom) layer of the palette is `tall_seagrass`, set to the bottom half variant. This Flora object can generate on Sand, Stone, Red Sand, Gravel, and Dirt. It can only replace Water blocks.","title":"Flora Configuration"},{"location":"packs/config-files/Flora-Configuration/#object-options","text":"Flora supports all Terra Object Options .","title":"Object Options"},{"location":"packs/config-files/Flora-Configuration/#options","text":"","title":"Options"},{"location":"packs/config-files/Flora-Configuration/#ceiling","text":"Whether this Flora object generates from the ceiling, or the floor. When true, the object will generate hanging from the ceiling. When false, the object will generate upwards from the floor. Note: This does not invert the layers (e.g. first layer will still be on the top, regardless of this option). This value is optional, and defaults false.","title":"ceiling"},{"location":"packs/config-files/Flora-Configuration/#spawnable","text":"A list of block IDs that this Flora object can spawn on.","title":"spawnable"},{"location":"packs/config-files/Flora-Configuration/#replaceable","text":"A list of block IDs that this Flora object can replace during generation.","title":"replaceable"},{"location":"packs/config-files/Flora-Configuration/#irrigable","text":"A list of blocks that must be bordering the block the Flora will be planted on for it to grow. This value is optional. It defaults to all blocks (allowing the Flora to grow on any spawnable block).","title":"irrigable"},{"location":"packs/config-files/Flora-Configuration/#rotatable","text":"A list of blocks that the flora item should be rotated to face. An example use case is sugarcane, where water would be the only item in this list, meaning sugarcane would only be able to grow bordering water.","title":"rotatable"},{"location":"packs/config-files/Flora-Configuration/#layers","text":"This option is identical to the layers option of a Block Palette , just interpreted differently. When generating Flora, each layer will be generated, starting with the topmost layer, and going downwards.","title":"layers"},{"location":"packs/config-files/Flora-Configuration/#examples","text":"Example Flora (Tall Seagrass) layers : - materials : - \"minecraft:tall_seagrass[half=upper]\" : 1 layers : 1 - materials : - \"minecraft:tall_seagrass[half=lower]\" : 1 layers : 1 id : TALL_SEAGRASS name : \"Tall Sea Grass\" spawnable : - \"minecraft:sand\" - \"minecraft:stone\" - \"minecraft:red_sand\" - \"minecraft:gravel\" - \"minecraft:dirt\" replaceable : - \"minecraft:water\" This config will generate a 2-block Seagrass plant. The top layer of the palette is `tall_seagrass`, set to the upper half variant. The second (bottom) layer of the palette is `tall_seagrass`, set to the bottom half variant. This Flora object can generate on Sand, Stone, Red Sand, Gravel, and Dirt. It can only replace Water blocks.","title":"Examples"},{"location":"packs/config-files/Ore-Configuration/","text":"Ores are materials that generate in veins throughout the world. Per Terra's rather loose definition, they do not even necessarily need to be made of ore, or even underground! Veins generate as deformed spheres, which is basically a sphere with its radius stretched and compressed at different points using noise. To experiment with this concept visually, use the /te geometry deformedsphere <radius> <deform> <frequency> command to generate such spheres in your world. Object Options \u00b6 Ores support all Terra Object Options . Options \u00b6 material \u00b6 BlockData string representing the material of the ore. Examples: * minecraft:gold_ore will generate Gold Ore. * minecraft:oak_fence[waterlogged=true] will generate waterlogged oak fences. This value is required. radius \u00b6 Minimum and maximum radii of the vein. * min - Minimum radius of the vein * max - Maximum radius of the vein. deform \u00b6 The amount by which to deform. The true meaning of this value is difficult to explain without the technical aspect. Technically, this value is the value multiplied by the deform noise value to produce the deformed sphere's radius at a point. Less technically, the further this value is from one, the more deformed the vein will be. Higher values make the vein larger, lower values make it smaller. This value is optional. (Defaults to 0.75) deform-frequency \u00b6 Frequency of the noise function used to deform the ore sphere. Higher values produce more \"scattered\" veins, values approaching zero produce increasingly spherical veins. This value is optional. (Defaults to 0.1) replace \u00b6 A list of block IDs that the ore can replace during generation. This value is required. update \u00b6 Whether to update the physics on blocks generated in the vein. This is required if you want liquid veins to have physics (to flow after generation). Do not enable this unless physics is required, as it will cause lag on large veins! This value is optional. (Defaults false) cross-chunks \u00b6 Whether ore veins are able to cross chunk borders. Disabling this may help increase performance. Defaults to true. Debugging \u00b6 Ore veins can be generated live using the /te ore <ID> command. This command will generate a vein of ore at the location you are looking at. It will only replace materials in the replaceable list, so make sure you're looking somewhere it can generate!","title":"Ore Configuration"},{"location":"packs/config-files/Ore-Configuration/#object-options","text":"Ores support all Terra Object Options .","title":"Object Options"},{"location":"packs/config-files/Ore-Configuration/#options","text":"","title":"Options"},{"location":"packs/config-files/Ore-Configuration/#material","text":"BlockData string representing the material of the ore. Examples: * minecraft:gold_ore will generate Gold Ore. * minecraft:oak_fence[waterlogged=true] will generate waterlogged oak fences. This value is required.","title":"material"},{"location":"packs/config-files/Ore-Configuration/#radius","text":"Minimum and maximum radii of the vein. * min - Minimum radius of the vein * max - Maximum radius of the vein.","title":"radius"},{"location":"packs/config-files/Ore-Configuration/#deform","text":"The amount by which to deform. The true meaning of this value is difficult to explain without the technical aspect. Technically, this value is the value multiplied by the deform noise value to produce the deformed sphere's radius at a point. Less technically, the further this value is from one, the more deformed the vein will be. Higher values make the vein larger, lower values make it smaller. This value is optional. (Defaults to 0.75)","title":"deform"},{"location":"packs/config-files/Ore-Configuration/#deform-frequency","text":"Frequency of the noise function used to deform the ore sphere. Higher values produce more \"scattered\" veins, values approaching zero produce increasingly spherical veins. This value is optional. (Defaults to 0.1)","title":"deform-frequency"},{"location":"packs/config-files/Ore-Configuration/#replace","text":"A list of block IDs that the ore can replace during generation. This value is required.","title":"replace"},{"location":"packs/config-files/Ore-Configuration/#update","text":"Whether to update the physics on blocks generated in the vein. This is required if you want liquid veins to have physics (to flow after generation). Do not enable this unless physics is required, as it will cause lag on large veins! This value is optional. (Defaults false)","title":"update"},{"location":"packs/config-files/Ore-Configuration/#cross-chunks","text":"Whether ore veins are able to cross chunk borders. Disabling this may help increase performance. Defaults to true.","title":"cross-chunks"},{"location":"packs/config-files/Ore-Configuration/#debugging","text":"Ore veins can be generated live using the /te ore <ID> command. This command will generate a vein of ore at the location you are looking at. It will only replace materials in the replaceable list, so make sure you're looking somewhere it can generate!","title":"Debugging"},{"location":"packs/config-files/Palette-Configuration/","text":"This page discusses the configuration of Block Palettes. For information on Block Palettes, see the About Block Palettes page. Palette configurations are in the palettes/ directory within a config pack. Object Options \u00b6 Palettes support all Terra Object Options . Options \u00b6 layers \u00b6 A list of palette layers. Each layer has a block layout, and can be configured to repeat for a number of blocks. Layer options \u00b6 materials - A weighted pool of materials and their weights. layers The number of blocks to repeat this layer for. (The \"depth\" of this layer). The actual depth of this layer is equal to the sum of the depths of all previous layers. The last layer of a palette will be repeated infinitely, regardless of its layers option. noise \u00b6 A Noise Configuration that defines placement of blocks in this palette. Defaults to 3D white noise. Examples \u00b6 Example Palette An example palette that generates 1 layer of Grass Blocks, 2 layers of Dirt underneath, then Stone for all remaining blocks. Its ID is `GRASSY`. layers : - materials : - \"minecraft:grass_block\" : 1 layers : 1 - materials : - \"minecraft:dirt\" : 1 layers : 2 - materials : - \"minecraft:stone\" : 1 layers : 1 id : GRASSY Example Simplex Palette An example palette that generates 2 layers of simplex-distributed Gravel, Dirt, and Sand. Dirt is more common, weighted at 4/7, followed by sand at 2/7, then gravel at 1/7. The seed of the Simplex generator is 3, and its frequency has been set to 0.05. Subsequent layers are Stone. layers : - materials : - \"minecraft:gravel\" : 1 - \"minecraft:dirt\" : 4 - \"minecraft:sand\" : 2 layers : 2 - materials : - \"minecraft:stone\" : 1 layers : 1 id : RIVER_BOTTOM simplex : true frequency : 0.05 seed : 3","title":"Palette Configuration"},{"location":"packs/config-files/Palette-Configuration/#object-options","text":"Palettes support all Terra Object Options .","title":"Object Options"},{"location":"packs/config-files/Palette-Configuration/#options","text":"","title":"Options"},{"location":"packs/config-files/Palette-Configuration/#layers","text":"A list of palette layers. Each layer has a block layout, and can be configured to repeat for a number of blocks.","title":"layers"},{"location":"packs/config-files/Palette-Configuration/#layer-options","text":"materials - A weighted pool of materials and their weights. layers The number of blocks to repeat this layer for. (The \"depth\" of this layer). The actual depth of this layer is equal to the sum of the depths of all previous layers. The last layer of a palette will be repeated infinitely, regardless of its layers option.","title":"Layer options"},{"location":"packs/config-files/Palette-Configuration/#noise","text":"A Noise Configuration that defines placement of blocks in this palette. Defaults to 3D white noise.","title":"noise"},{"location":"packs/config-files/Palette-Configuration/#examples","text":"Example Palette An example palette that generates 1 layer of Grass Blocks, 2 layers of Dirt underneath, then Stone for all remaining blocks. Its ID is `GRASSY`. layers : - materials : - \"minecraft:grass_block\" : 1 layers : 1 - materials : - \"minecraft:dirt\" : 1 layers : 2 - materials : - \"minecraft:stone\" : 1 layers : 1 id : GRASSY Example Simplex Palette An example palette that generates 2 layers of simplex-distributed Gravel, Dirt, and Sand. Dirt is more common, weighted at 4/7, followed by sand at 2/7, then gravel at 1/7. The seed of the Simplex generator is 3, and its frequency has been set to 0.05. Subsequent layers are Stone. layers : - materials : - \"minecraft:gravel\" : 1 - \"minecraft:dirt\" : 4 - \"minecraft:sand\" : 2 layers : 2 - materials : - \"minecraft:stone\" : 1 layers : 1 id : RIVER_BOTTOM simplex : true frequency : 0.05 seed : 3","title":"Examples"},{"location":"packs/config-files/Structure-Configuration/","text":"This page discusses the configuration of Structures. Structure configurations are in the structures/single/ directory within a config pack. Structure files are in the structures/data/ directory within a config pack. Loot tables are in the structures/loot directory within a config pack. Object Options \u00b6 Structures support all Terra Object Options . Options \u00b6 scripts \u00b6 A weighted pool of structure script IDs and their weights. spawn \u00b6 Options for structure spawning. * start - Range in which to begin Y-value checking. A random value will be selected from this range, and Terra will search downwards until either a spawn that matches the structure's spawn signs can be found, or until the Y-value is out of range. * min - Minimum Y-value to begin searching. * max - Maximum y-value to begin searching. * width - Width of cells in the padded grid to use for structure placement. * padding - Padding between cells in the padded grid used for structure placement. Example of width and padding in a padded grid. Black dots represent structure spawn locations. loot \u00b6 Loot tables to use for this structure. Keys represent Loot Table IDs , and values represent the loot table file to use (sans .json ). Loot table files go in the structures/loot directory. They can be generated with any Vanilla loot table generation utility , as they are a re-implementation of Vanilla loot table syntax.","title":"Structure Configuration"},{"location":"packs/config-files/Structure-Configuration/#object-options","text":"Structures support all Terra Object Options .","title":"Object Options"},{"location":"packs/config-files/Structure-Configuration/#options","text":"","title":"Options"},{"location":"packs/config-files/Structure-Configuration/#scripts","text":"A weighted pool of structure script IDs and their weights.","title":"scripts"},{"location":"packs/config-files/Structure-Configuration/#spawn","text":"Options for structure spawning. * start - Range in which to begin Y-value checking. A random value will be selected from this range, and Terra will search downwards until either a spawn that matches the structure's spawn signs can be found, or until the Y-value is out of range. * min - Minimum Y-value to begin searching. * max - Maximum y-value to begin searching. * width - Width of cells in the padded grid to use for structure placement. * padding - Padding between cells in the padded grid used for structure placement. Example of width and padding in a padded grid. Black dots represent structure spawn locations.","title":"spawn"},{"location":"packs/config-files/Structure-Configuration/#loot","text":"Loot tables to use for this structure. Keys represent Loot Table IDs , and values represent the loot table file to use (sans .json ). Loot table files go in the structures/loot directory. They can be generated with any Vanilla loot table generation utility , as they are a re-implementation of Vanilla loot table syntax.","title":"loot"},{"location":"packs/config-files/Tree-Configuration/","text":"This page discusses the configuration of Custom Structure Trees. For information on included trees, see the Trees page. Tree configurations are in the structures/trees/ directory within a config pack. Tree structure files are in the structures/data/ directory within a config pack (Same directory as standard structures). Object Options \u00b6 Trees support all Terra Object Options . Options \u00b6 y-offset \u00b6 An integer to add to the Y-value of generation. Useful for trees that have large underground portions. This value can be negative. spawnable \u00b6 A list of Block IDs that this tree can spawn on files \u00b6 A weighted pool of structure filenames (sans .tstructure ) and their weights. The files must be located in the Tree data directory ( trees/data/ ). Example \u00b6 Example Custom Tree files : spruce1 : 1 spruce2 : 2 id : SPRUCE_CUSTOM y-offset : 0 spawnable : - \"minecraft:grass_block\" This custom tree has an ID of `SPRUCE_CUSTOM`. It can spawn on Grass Blocks, has a y-offset of zero, and has 2 structure files, `spruce1.tstructure` with weight 1, and `spruce2.tstructure` with weight 2.","title":"Tree Configuration"},{"location":"packs/config-files/Tree-Configuration/#object-options","text":"Trees support all Terra Object Options .","title":"Object Options"},{"location":"packs/config-files/Tree-Configuration/#options","text":"","title":"Options"},{"location":"packs/config-files/Tree-Configuration/#y-offset","text":"An integer to add to the Y-value of generation. Useful for trees that have large underground portions. This value can be negative.","title":"y-offset"},{"location":"packs/config-files/Tree-Configuration/#spawnable","text":"A list of Block IDs that this tree can spawn on","title":"spawnable"},{"location":"packs/config-files/Tree-Configuration/#files","text":"A weighted pool of structure filenames (sans .tstructure ) and their weights. The files must be located in the Tree data directory ( trees/data/ ).","title":"files"},{"location":"packs/config-files/Tree-Configuration/#example","text":"Example Custom Tree files : spruce1 : 1 spruce2 : 2 id : SPRUCE_CUSTOM y-offset : 0 spawnable : - \"minecraft:grass_block\" This custom tree has an ID of `SPRUCE_CUSTOM`. It can spawn on Grass Blocks, has a y-offset of zero, and has 2 structure files, `spruce1.tstructure` with weight 1, and `spruce2.tstructure` with weight 2.","title":"Example"},{"location":"packs/config-files/pack.yml-Options/","text":"pack.yml is a required file located in the root of all Terra config packs. It defines universal pack options like biome blending, biome selection, and erosion. Configuration \u00b6 id \u00b6 The ID of the config pack. This should be unique (not something generic like \"overworld,\" since users may wish to install multiple config packs). author \u00b6 Put your name here! The author option allows you to take credit for the cool things you make with Terra. It is displayed on config load. version \u00b6 The version of your config pack. biomes \u00b6 Options for biome distribution. type \u00b6 Biome Provider type. Provider types are: * SINGLE - Single-biome provider. Useful for biome debugging. * IMAGE - Image provider, for pulling biome selections from an image. * PIPELINE - Biome Pipeline distribution system. SINGLE Options \u00b6 biome \u00b6 Biome to use in single-biome provider. IMAGE Options \u00b6 When using this provider, the biome with the color attribute closest to an image pixel will be chosen. image.name \u00b6 Name of the image to use for biome selections. PIPELINE Options \u00b6 See the Biome Pipeline page. noise \u00b6 This configuration section contains options for the noise functions to use in world generation. Each entry defines a custom noise function that may be invoked inside noise equations. Each entry is a key-value pair, where the key is the identifier to use for the noise function, and the value is a Noise Configuration . Example Noise Configuration An example noise configuration that defines the `noise2` and `noise3` functions you know and love. noise : noise2 : dimensions : 2 type : OpenSimplex2 frequency : 0.0075 fractal : type : FBm octaves : 5 noise3 : dimensions : 3 type : OpenSimplex2 frequency : 0.0075 fractal : type : FBm octaves : 5 variables \u00b6 Variables that may be used in noise equations within this config. variables : var : 2 The above config would define a variable called var with a value of 2. It may be used in any noise or elevation equations. functions \u00b6 Functions that may be used in noise equations. Useful for reducing boilerplate. Example: functions : fourMax : arguments : # Four arguments, a b c and d - a - b - c - d function : \"max(max(max(a, b), c), d)\"","title":"pack.yml Options"},{"location":"packs/config-files/pack.yml-Options/#configuration","text":"","title":"Configuration"},{"location":"packs/config-files/pack.yml-Options/#id","text":"The ID of the config pack. This should be unique (not something generic like \"overworld,\" since users may wish to install multiple config packs).","title":"id"},{"location":"packs/config-files/pack.yml-Options/#author","text":"Put your name here! The author option allows you to take credit for the cool things you make with Terra. It is displayed on config load.","title":"author"},{"location":"packs/config-files/pack.yml-Options/#version","text":"The version of your config pack.","title":"version"},{"location":"packs/config-files/pack.yml-Options/#biomes","text":"Options for biome distribution.","title":"biomes"},{"location":"packs/config-files/pack.yml-Options/#type","text":"Biome Provider type. Provider types are: * SINGLE - Single-biome provider. Useful for biome debugging. * IMAGE - Image provider, for pulling biome selections from an image. * PIPELINE - Biome Pipeline distribution system.","title":"type"},{"location":"packs/config-files/pack.yml-Options/#single-options","text":"","title":"SINGLE Options"},{"location":"packs/config-files/pack.yml-Options/#biome","text":"Biome to use in single-biome provider.","title":"biome"},{"location":"packs/config-files/pack.yml-Options/#image-options","text":"When using this provider, the biome with the color attribute closest to an image pixel will be chosen.","title":"IMAGE Options"},{"location":"packs/config-files/pack.yml-Options/#imagename","text":"Name of the image to use for biome selections.","title":"image.name"},{"location":"packs/config-files/pack.yml-Options/#pipeline-options","text":"See the Biome Pipeline page.","title":"PIPELINE Options"},{"location":"packs/config-files/pack.yml-Options/#noise","text":"This configuration section contains options for the noise functions to use in world generation. Each entry defines a custom noise function that may be invoked inside noise equations. Each entry is a key-value pair, where the key is the identifier to use for the noise function, and the value is a Noise Configuration . Example Noise Configuration An example noise configuration that defines the `noise2` and `noise3` functions you know and love. noise : noise2 : dimensions : 2 type : OpenSimplex2 frequency : 0.0075 fractal : type : FBm octaves : 5 noise3 : dimensions : 3 type : OpenSimplex2 frequency : 0.0075 fractal : type : FBm octaves : 5","title":"noise"},{"location":"packs/config-files/pack.yml-Options/#variables","text":"Variables that may be used in noise equations within this config. variables : var : 2 The above config would define a variable called var with a value of 2. It may be used in any noise or elevation equations.","title":"variables"},{"location":"packs/config-files/pack.yml-Options/#functions","text":"Functions that may be used in noise equations. Useful for reducing boilerplate. Example: functions : fourMax : arguments : # Four arguments, a b c and d - a - b - c - d function : \"max(max(max(a, b), c), d)\"","title":"functions"},{"location":"packs/other/Biome-Pipeline/","text":"The Biome Pipeline is a powerful tool that allows for customization of the distribution of biomes in the world. Pipeline Options \u00b6 initial-size \u00b6 The initial size of biome chunks. This value must be at least 2. This is not the final size of biome chunks. Final chunks will be much larger . It is recommended to keep biome chunks' final size in the range of [50, 300] to prevent performance issues. To calculate the size of biome chunks, simply take initial-size and for each expand stage, multiply the running value by 2 and subtract 1. (The size is also printed to the server console if you have debug mode enabled) source \u00b6 The Biome Source to use to provide base biomes for the pipeline to work with. Generally this provides very few biomes, used to define the largest stage of the world. In overworld configs, for example, the biome source is generally used to define land/ocean layout. Source Options \u00b6 type \u00b6 The type of biome source to use. Available source types: * NOISE - Use a noise function to distribute source biomes. biomes \u00b6 A Weighted Pool of biomes to use for selection. noise \u00b6 The noise configuration to use for selection. (End source options) stages \u00b6 List of stages. The source biomes are passed through these stages sequentially, and each stage applies an operation to the biomes. Stage Options \u00b6 Stages are defined by a key specifying stage type, with a value containing stage options. Stage types: * expand - Expand the biome selection. Expander stages are helpful to get rid of noise artifacts. * mutate - Mutate the biome selection. Mutators allow you to manipulate the biome selection by replacing biomes, adding borders, and more. All stages have the following options: noise \u00b6 The noise function to be used for the stage. Different stages use noise functions in different ways, which will be explained below. Expander Stage Options \u00b6 type \u00b6 Type of expander to use. Expander types: * FRACTAL - Fractal expander using cellular automaton. In this expander type, the noise function defines which biome to choose if a priority tie occurs. Generally, white noise is used here. Mutator Stage Options \u00b6 type \u00b6 Type of mutator to apply. Mutator types: * REPLACE - Replace a tag with a weighted pool of biomes. The stage noise function is used for selections from the pool. * REPLACE_LIST - Replace a list of biomes with per-biome weighted pool, with a default tag/replace list. This is a boilerplate-reducing option for when many biomes are being replaced with specific replacements. The stage noise function is used for selections from the pools. * BORDER - Replace a biome whenever it borders another biome from a weighted pool. The stage noise function is used for selections from the pool. * BORDER_LIST - Another boilerplate-reducing mutator, similar to REPLACE_LIST . The stage noise function is used for selections from the pools. * SMOOTH - Smooth rough edges left by expand stages. The stage noise function is used to choose biomes in the case of a priority tie. REPLACE Options \u00b6 from \u00b6 Biomes with this tag will be replaced. to \u00b6 Weighted Pool of biomes to use as replacements. REPLACE_LIST Options \u00b6 to \u00b6 Map of Biome ID to Weighted Pool . Biomes here will be specially replaced with selections from their weighted pools. default-from \u00b6 Biomes with this tag will be replaced by the default pool, provided that no to biomes match. default-to \u00b6 Weighted Pool of biomes to use as replacements for biomes matching default-from . BORDER Options \u00b6 from \u00b6 Tag to trigger border replacement. replace \u00b6 Biomes with this tag will be replaced, if they are bordering a biome tagged with from . to \u00b6 Weighted Pool of biomes to use as replacements. BORDER_LIST Options \u00b6 from \u00b6 Tag to trigger border replacement. replace \u00b6 Map of Biome ID to Weighted Pool . Biomes here will be specially replaced with selections from their weighted pools. default-replace \u00b6 Biomes with this tag will be replaced by the default pool, provided that no to biomes match. default-to \u00b6 Weighted Pool of biomes to use as replacements for biomes matching default-from . A commented pipeline is available in the Default Config's pack.yml .","title":"Other"},{"location":"packs/other/Biome-Pipeline/#pipeline-options","text":"","title":"Pipeline Options"},{"location":"packs/other/Biome-Pipeline/#initial-size","text":"The initial size of biome chunks. This value must be at least 2. This is not the final size of biome chunks. Final chunks will be much larger . It is recommended to keep biome chunks' final size in the range of [50, 300] to prevent performance issues. To calculate the size of biome chunks, simply take initial-size and for each expand stage, multiply the running value by 2 and subtract 1. (The size is also printed to the server console if you have debug mode enabled)","title":"initial-size"},{"location":"packs/other/Biome-Pipeline/#source","text":"The Biome Source to use to provide base biomes for the pipeline to work with. Generally this provides very few biomes, used to define the largest stage of the world. In overworld configs, for example, the biome source is generally used to define land/ocean layout.","title":"source"},{"location":"packs/other/Biome-Pipeline/#source-options","text":"","title":"Source Options"},{"location":"packs/other/Biome-Pipeline/#type","text":"The type of biome source to use. Available source types: * NOISE - Use a noise function to distribute source biomes.","title":"type"},{"location":"packs/other/Biome-Pipeline/#biomes","text":"A Weighted Pool of biomes to use for selection.","title":"biomes"},{"location":"packs/other/Biome-Pipeline/#noise","text":"The noise configuration to use for selection. (End source options)","title":"noise"},{"location":"packs/other/Biome-Pipeline/#stages","text":"List of stages. The source biomes are passed through these stages sequentially, and each stage applies an operation to the biomes.","title":"stages"},{"location":"packs/other/Biome-Pipeline/#stage-options","text":"Stages are defined by a key specifying stage type, with a value containing stage options. Stage types: * expand - Expand the biome selection. Expander stages are helpful to get rid of noise artifacts. * mutate - Mutate the biome selection. Mutators allow you to manipulate the biome selection by replacing biomes, adding borders, and more. All stages have the following options:","title":"Stage Options"},{"location":"packs/other/Biome-Pipeline/#noise_1","text":"The noise function to be used for the stage. Different stages use noise functions in different ways, which will be explained below.","title":"noise"},{"location":"packs/other/Biome-Pipeline/#expander-stage-options","text":"","title":"Expander Stage Options"},{"location":"packs/other/Biome-Pipeline/#type_1","text":"Type of expander to use. Expander types: * FRACTAL - Fractal expander using cellular automaton. In this expander type, the noise function defines which biome to choose if a priority tie occurs. Generally, white noise is used here.","title":"type"},{"location":"packs/other/Biome-Pipeline/#mutator-stage-options","text":"","title":"Mutator Stage Options"},{"location":"packs/other/Biome-Pipeline/#type_2","text":"Type of mutator to apply. Mutator types: * REPLACE - Replace a tag with a weighted pool of biomes. The stage noise function is used for selections from the pool. * REPLACE_LIST - Replace a list of biomes with per-biome weighted pool, with a default tag/replace list. This is a boilerplate-reducing option for when many biomes are being replaced with specific replacements. The stage noise function is used for selections from the pools. * BORDER - Replace a biome whenever it borders another biome from a weighted pool. The stage noise function is used for selections from the pool. * BORDER_LIST - Another boilerplate-reducing mutator, similar to REPLACE_LIST . The stage noise function is used for selections from the pools. * SMOOTH - Smooth rough edges left by expand stages. The stage noise function is used to choose biomes in the case of a priority tie.","title":"type"},{"location":"packs/other/Biome-Pipeline/#replace-options","text":"","title":"REPLACE Options"},{"location":"packs/other/Biome-Pipeline/#from","text":"Biomes with this tag will be replaced.","title":"from"},{"location":"packs/other/Biome-Pipeline/#to","text":"Weighted Pool of biomes to use as replacements.","title":"to"},{"location":"packs/other/Biome-Pipeline/#replace_list-options","text":"","title":"REPLACE_LIST Options"},{"location":"packs/other/Biome-Pipeline/#to_1","text":"Map of Biome ID to Weighted Pool . Biomes here will be specially replaced with selections from their weighted pools.","title":"to"},{"location":"packs/other/Biome-Pipeline/#default-from","text":"Biomes with this tag will be replaced by the default pool, provided that no to biomes match.","title":"default-from"},{"location":"packs/other/Biome-Pipeline/#default-to","text":"Weighted Pool of biomes to use as replacements for biomes matching default-from .","title":"default-to"},{"location":"packs/other/Biome-Pipeline/#border-options","text":"","title":"BORDER Options"},{"location":"packs/other/Biome-Pipeline/#from_1","text":"Tag to trigger border replacement.","title":"from"},{"location":"packs/other/Biome-Pipeline/#replace","text":"Biomes with this tag will be replaced, if they are bordering a biome tagged with from .","title":"replace"},{"location":"packs/other/Biome-Pipeline/#to_2","text":"Weighted Pool of biomes to use as replacements.","title":"to"},{"location":"packs/other/Biome-Pipeline/#border_list-options","text":"","title":"BORDER_LIST Options"},{"location":"packs/other/Biome-Pipeline/#from_2","text":"Tag to trigger border replacement.","title":"from"},{"location":"packs/other/Biome-Pipeline/#replace_1","text":"Map of Biome ID to Weighted Pool . Biomes here will be specially replaced with selections from their weighted pools.","title":"replace"},{"location":"packs/other/Biome-Pipeline/#default-replace","text":"Biomes with this tag will be replaced by the default pool, provided that no to biomes match.","title":"default-replace"},{"location":"packs/other/Biome-Pipeline/#default-to_1","text":"Weighted Pool of biomes to use as replacements for biomes matching default-from . A commented pipeline is available in the Default Config's pack.yml .","title":"default-to"},{"location":"packs/other/Functions-and-Variables/","text":"Math Functions \u00b6 Here is a list of all the math functions and variables available to you in Terra. These can be used anywhere you have access to a function Variables \u00b6 Here is a list of all the variables you have access to for all equations seed \u00b6 The seed variables holds the current world seed. This can be passed to the rand function, which requires a seed. x \u00b6 The current x coordinate. y \u00b6 The current y coordinate. Note: this variable does not exist for functions with 2d noise. z \u00b6 The current z coordinate. Functions \u00b6 sin \u00b6 Returns the trigonometric sine of an angle. Special cases: - If the argument is NaN or an infinity, then the result is NaN . - If the argument is zero, then the result is a zero with the same sign as the argument. Assume this works the same as the Java Math#sin function. cos \u00b6 Returns the trigonometric cosine of an angle. Special cases: - If the argument is NaN or an infinity, then the result is NaN . Assume this works the same as the Java Math#cos function. tan \u00b6 Returns the trigonometric tangent of an angle. Special cases: - If the argument is NaN or an infinity, then the result is NaN . - If the argument is zero, then the result is a zero with the same sign as the argument. Assume this works the same as the Java Math#tan function. sinh \u00b6 Returns the hyperbolic sine of a double value. The hyperbolic sine of x is defined to be (ex - e-x)/2 where e is Euler's number. Special cases: - If the argument is NaN, then the result is NaN. - If the argument is infinite, then the result is an infinity with the same sign as the argument. - If the argument is zero, then the result is a zero with the same sign as the argument. Assume this works the same as the Java Math#sinh function. cosh \u00b6 Returns the hyperbolic cosine of a double value. The hyperbolic cosine of x is defined to be (ex + e-x)/2 where e is Euler's number. Special cases: - If the argument is NaN, then the result is NaN. - If the argument is infinite, then the result is positive infinity. - If the argument is zero, then the result is 1.0 . Assume this works the same as the Java Math#cosh function. tanh \u00b6 Returns the hyperbolic tangent of a double value. The hyperbolic tangent of x is defined to be (ex - e-x)/(ex + e-x) , in other words, sinh(x)/cosh(x) . Note that the absolute value of the exact tanh is always less than 1. Special cases: - If the argument is NaN, then the result is NaN. - If the argument is zero, then the result is a zero with the same sign as the argument. - If the argument is positive infinity, then the result is +1.0. - If the argument is negative infinity, then the result is -1.0. Assume this works the same as the Java Math#tanh function. asin \u00b6 Returns the arc sine of a value; the returned angle is in the range -pi/2 through pi/2 . Special cases: - If the argument is NaN or its absolute value is greater than 1, then the result is NaN. - If the argument is zero, then the result is a zero with the same sign as the argument. Assume this works the same as the Java Math#asin function. acos \u00b6 Returns the arc cosine of a value; the returned angle is in the range 0.0 through pi. Special case: - If the argument is NaN or its absolute value is greater than 1, then the result is NaN. Assume this works the same as the Java Math#acos function. atan \u00b6 Returns the arc tangent of a value; the returned angle is in the range -pi/2 through pi/2 . Special cases: - If the argument is NaN, then the result is NaN . - If the argument is zero, then the result is a zero with the same sign as the argument. Assume this works the same as the Java Math#atan function. atan2 \u00b6 Returns the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta) . This method computes the phase theta by computing an arc tangent of y/x in the range of -pi to pi . Special cases: - If either argument is NaN, then the result is NaN. - If the first argument is positive zero and the second argument is positive, or the first argument is positive and finite and the second argument is positive infinity, then the result is positive zero. - If the first argument is negative zero and the second argument is positive, or the first argument is negative and finite and the second argument is positive infinity, then the result is negative zero. - If the first argument is positive zero and the second argument is negative, or the first argument is positive and finite and the second argument is negative infinity, then the result is the double value closest to pi . - If the first argument is negative zero and the second argument is negative, or the first argument is negative and finite and the second argument is negative infinity, then the result is the double value closest to -pi . - If the first argument is positive and the second argument is positive zero or negative zero, or the first argument is positive infinity and the second argument is finite, then the result is the double value closest to pi/2 . - If the first argument is negative and the second argument is positive zero or negative zero, or the first argument is negative infinity and the second argument is finite, then the result is the double value closest to -pi/2 . - If both arguments are positive infinity, then the result is the double value closest to pi/4 . - If the first argument is positive infinity and the second argument is negative infinity, then the result is the double value closest to 3*pi/4 . - If the first argument is negative infinity and the second argument is positive infinity, then the result is the double value closest to -pi/4 . - If both arguments are negative infinity, then the result is the double value closest to -3*pi/4. Assume this works the same as the Java Math#atan2 function. deg \u00b6 Converts an angle measured in radians to an approximately equivalent angle measured in degrees. The conversion from radians to degrees is generally inexact; users should not expect cos(toRadians(90.0)) to exactly equal 0.0. This is the same as doing x * 180 / 3.14159... . Assume this works the same as the Java Math#atan2 function. rad \u00b6 Converts an angle measured in degrees to an approximately equivalent angle measured in radians. The conversion from degrees to radians is generally inexact. This is the same as doing x * 3.15159... / 180 . Assume this works the same as the Java Math#atan2 function. abs \u00b6 Returns the absolute value of a float value. If the argument is not negative, the argument is returned. If the argument is negative, the negation of the argument is returned. Special cases: - If the argument is positive zero or negative zero, the result is positive zero. - If the argument is infinite, the result is positive infinity. - If the argument is NaN, the result is NaN. Assume this works the same as the Java Math#atan2 function. round \u00b6 Returns the closest integer to the argument, with ties rounding to positive infinity. Special cases: - If the argument is NaN , the result is 0 . - If the argument is negative infinity or any value less than or equal to the value of Long.MIN_VALUE , the result is equal to the value of Long.MIN_VALUE . - If the argument is positive infinity or any value greater than or equal to the value of Long.MAX_VALUE , the result is equal to the value of Long.MAX_VALUE . Assume this works the same as the Java Math#atan2 function. ceil \u00b6 Returns the smallest (closest to negative infinity) value that is greater than or equal to the argument and is equal to a mathematical integer. Special cases: - If the argument value is already equal to a mathematical integer, then the result is the same as the argument. - If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument. - If the argument value is less than zero but greater than -1.0, then the result is negative zero. Note that the value of ceil(x) is exactly the value of -floor(-x). Assume this works the same as the Java Math#atan2 function. floor \u00b6 Returns the largest (closest to positive infinity) value that is less than or equal to the argument and is equal to a mathematical integer. Special cases: - If the argument value is already equal to a mathematical integer, then the result is the same as the argument. - If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument. exp \u00b6 Returns Euler's number e raised to the power of a value. Special cases: - If the argument is NaN, the result is NaN. - If the argument is positive infinity, then the result is positive infinity. - If the argument is negative infinity, then the result is positive zero. ln \u00b6 log \u00b6 sqrt \u00b6 pow \u00b6 min \u00b6 max \u00b6 sign \u00b6 if \u00b6 root \u00b6 cbrt \u00b6 sigmoid \u00b6 int_and \u00b6 int_left_bit_shift \u00b6 int_right_bit_shift \u00b6 int_not \u00b6 int_or \u00b6 int_xor \u00b6 double_to_long_bits \u00b6 long_bits_to_double \u00b6 float_bits_to_int \u00b6 int_bits_to_float \u00b6","title":"Math Functions"},{"location":"packs/other/Functions-and-Variables/#math-functions","text":"Here is a list of all the math functions and variables available to you in Terra. These can be used anywhere you have access to a function","title":"Math Functions"},{"location":"packs/other/Functions-and-Variables/#variables","text":"Here is a list of all the variables you have access to for all equations","title":"Variables"},{"location":"packs/other/Functions-and-Variables/#seed","text":"The seed variables holds the current world seed. This can be passed to the rand function, which requires a seed.","title":"seed"},{"location":"packs/other/Functions-and-Variables/#x","text":"The current x coordinate.","title":"x"},{"location":"packs/other/Functions-and-Variables/#y","text":"The current y coordinate. Note: this variable does not exist for functions with 2d noise.","title":"y"},{"location":"packs/other/Functions-and-Variables/#z","text":"The current z coordinate.","title":"z"},{"location":"packs/other/Functions-and-Variables/#functions","text":"","title":"Functions"},{"location":"packs/other/Functions-and-Variables/#sin","text":"Returns the trigonometric sine of an angle. Special cases: - If the argument is NaN or an infinity, then the result is NaN . - If the argument is zero, then the result is a zero with the same sign as the argument. Assume this works the same as the Java Math#sin function.","title":"sin"},{"location":"packs/other/Functions-and-Variables/#cos","text":"Returns the trigonometric cosine of an angle. Special cases: - If the argument is NaN or an infinity, then the result is NaN . Assume this works the same as the Java Math#cos function.","title":"cos"},{"location":"packs/other/Functions-and-Variables/#tan","text":"Returns the trigonometric tangent of an angle. Special cases: - If the argument is NaN or an infinity, then the result is NaN . - If the argument is zero, then the result is a zero with the same sign as the argument. Assume this works the same as the Java Math#tan function.","title":"tan"},{"location":"packs/other/Functions-and-Variables/#sinh","text":"Returns the hyperbolic sine of a double value. The hyperbolic sine of x is defined to be (ex - e-x)/2 where e is Euler's number. Special cases: - If the argument is NaN, then the result is NaN. - If the argument is infinite, then the result is an infinity with the same sign as the argument. - If the argument is zero, then the result is a zero with the same sign as the argument. Assume this works the same as the Java Math#sinh function.","title":"sinh"},{"location":"packs/other/Functions-and-Variables/#cosh","text":"Returns the hyperbolic cosine of a double value. The hyperbolic cosine of x is defined to be (ex + e-x)/2 where e is Euler's number. Special cases: - If the argument is NaN, then the result is NaN. - If the argument is infinite, then the result is positive infinity. - If the argument is zero, then the result is 1.0 . Assume this works the same as the Java Math#cosh function.","title":"cosh"},{"location":"packs/other/Functions-and-Variables/#tanh","text":"Returns the hyperbolic tangent of a double value. The hyperbolic tangent of x is defined to be (ex - e-x)/(ex + e-x) , in other words, sinh(x)/cosh(x) . Note that the absolute value of the exact tanh is always less than 1. Special cases: - If the argument is NaN, then the result is NaN. - If the argument is zero, then the result is a zero with the same sign as the argument. - If the argument is positive infinity, then the result is +1.0. - If the argument is negative infinity, then the result is -1.0. Assume this works the same as the Java Math#tanh function.","title":"tanh"},{"location":"packs/other/Functions-and-Variables/#asin","text":"Returns the arc sine of a value; the returned angle is in the range -pi/2 through pi/2 . Special cases: - If the argument is NaN or its absolute value is greater than 1, then the result is NaN. - If the argument is zero, then the result is a zero with the same sign as the argument. Assume this works the same as the Java Math#asin function.","title":"asin"},{"location":"packs/other/Functions-and-Variables/#acos","text":"Returns the arc cosine of a value; the returned angle is in the range 0.0 through pi. Special case: - If the argument is NaN or its absolute value is greater than 1, then the result is NaN. Assume this works the same as the Java Math#acos function.","title":"acos"},{"location":"packs/other/Functions-and-Variables/#atan","text":"Returns the arc tangent of a value; the returned angle is in the range -pi/2 through pi/2 . Special cases: - If the argument is NaN, then the result is NaN . - If the argument is zero, then the result is a zero with the same sign as the argument. Assume this works the same as the Java Math#atan function.","title":"atan"},{"location":"packs/other/Functions-and-Variables/#atan2","text":"Returns the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta) . This method computes the phase theta by computing an arc tangent of y/x in the range of -pi to pi . Special cases: - If either argument is NaN, then the result is NaN. - If the first argument is positive zero and the second argument is positive, or the first argument is positive and finite and the second argument is positive infinity, then the result is positive zero. - If the first argument is negative zero and the second argument is positive, or the first argument is negative and finite and the second argument is positive infinity, then the result is negative zero. - If the first argument is positive zero and the second argument is negative, or the first argument is positive and finite and the second argument is negative infinity, then the result is the double value closest to pi . - If the first argument is negative zero and the second argument is negative, or the first argument is negative and finite and the second argument is negative infinity, then the result is the double value closest to -pi . - If the first argument is positive and the second argument is positive zero or negative zero, or the first argument is positive infinity and the second argument is finite, then the result is the double value closest to pi/2 . - If the first argument is negative and the second argument is positive zero or negative zero, or the first argument is negative infinity and the second argument is finite, then the result is the double value closest to -pi/2 . - If both arguments are positive infinity, then the result is the double value closest to pi/4 . - If the first argument is positive infinity and the second argument is negative infinity, then the result is the double value closest to 3*pi/4 . - If the first argument is negative infinity and the second argument is positive infinity, then the result is the double value closest to -pi/4 . - If both arguments are negative infinity, then the result is the double value closest to -3*pi/4. Assume this works the same as the Java Math#atan2 function.","title":"atan2"},{"location":"packs/other/Functions-and-Variables/#deg","text":"Converts an angle measured in radians to an approximately equivalent angle measured in degrees. The conversion from radians to degrees is generally inexact; users should not expect cos(toRadians(90.0)) to exactly equal 0.0. This is the same as doing x * 180 / 3.14159... . Assume this works the same as the Java Math#atan2 function.","title":"deg"},{"location":"packs/other/Functions-and-Variables/#rad","text":"Converts an angle measured in degrees to an approximately equivalent angle measured in radians. The conversion from degrees to radians is generally inexact. This is the same as doing x * 3.15159... / 180 . Assume this works the same as the Java Math#atan2 function.","title":"rad"},{"location":"packs/other/Functions-and-Variables/#abs","text":"Returns the absolute value of a float value. If the argument is not negative, the argument is returned. If the argument is negative, the negation of the argument is returned. Special cases: - If the argument is positive zero or negative zero, the result is positive zero. - If the argument is infinite, the result is positive infinity. - If the argument is NaN, the result is NaN. Assume this works the same as the Java Math#atan2 function.","title":"abs"},{"location":"packs/other/Functions-and-Variables/#round","text":"Returns the closest integer to the argument, with ties rounding to positive infinity. Special cases: - If the argument is NaN , the result is 0 . - If the argument is negative infinity or any value less than or equal to the value of Long.MIN_VALUE , the result is equal to the value of Long.MIN_VALUE . - If the argument is positive infinity or any value greater than or equal to the value of Long.MAX_VALUE , the result is equal to the value of Long.MAX_VALUE . Assume this works the same as the Java Math#atan2 function.","title":"round"},{"location":"packs/other/Functions-and-Variables/#ceil","text":"Returns the smallest (closest to negative infinity) value that is greater than or equal to the argument and is equal to a mathematical integer. Special cases: - If the argument value is already equal to a mathematical integer, then the result is the same as the argument. - If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument. - If the argument value is less than zero but greater than -1.0, then the result is negative zero. Note that the value of ceil(x) is exactly the value of -floor(-x). Assume this works the same as the Java Math#atan2 function.","title":"ceil"},{"location":"packs/other/Functions-and-Variables/#floor","text":"Returns the largest (closest to positive infinity) value that is less than or equal to the argument and is equal to a mathematical integer. Special cases: - If the argument value is already equal to a mathematical integer, then the result is the same as the argument. - If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument.","title":"floor"},{"location":"packs/other/Functions-and-Variables/#exp","text":"Returns Euler's number e raised to the power of a value. Special cases: - If the argument is NaN, the result is NaN. - If the argument is positive infinity, then the result is positive infinity. - If the argument is negative infinity, then the result is positive zero.","title":"exp"},{"location":"packs/other/Functions-and-Variables/#ln","text":"","title":"ln"},{"location":"packs/other/Functions-and-Variables/#log","text":"","title":"log"},{"location":"packs/other/Functions-and-Variables/#sqrt","text":"","title":"sqrt"},{"location":"packs/other/Functions-and-Variables/#pow","text":"","title":"pow"},{"location":"packs/other/Functions-and-Variables/#min","text":"","title":"min"},{"location":"packs/other/Functions-and-Variables/#max","text":"","title":"max"},{"location":"packs/other/Functions-and-Variables/#sign","text":"","title":"sign"},{"location":"packs/other/Functions-and-Variables/#if","text":"","title":"if"},{"location":"packs/other/Functions-and-Variables/#root","text":"","title":"root"},{"location":"packs/other/Functions-and-Variables/#cbrt","text":"","title":"cbrt"},{"location":"packs/other/Functions-and-Variables/#sigmoid","text":"","title":"sigmoid"},{"location":"packs/other/Functions-and-Variables/#int_and","text":"","title":"int_and"},{"location":"packs/other/Functions-and-Variables/#int_left_bit_shift","text":"","title":"int_left_bit_shift"},{"location":"packs/other/Functions-and-Variables/#int_right_bit_shift","text":"","title":"int_right_bit_shift"},{"location":"packs/other/Functions-and-Variables/#int_not","text":"","title":"int_not"},{"location":"packs/other/Functions-and-Variables/#int_or","text":"","title":"int_or"},{"location":"packs/other/Functions-and-Variables/#int_xor","text":"","title":"int_xor"},{"location":"packs/other/Functions-and-Variables/#double_to_long_bits","text":"","title":"double_to_long_bits"},{"location":"packs/other/Functions-and-Variables/#long_bits_to_double","text":"","title":"long_bits_to_double"},{"location":"packs/other/Functions-and-Variables/#float_bits_to_int","text":"","title":"float_bits_to_int"},{"location":"packs/other/Functions-and-Variables/#int_bits_to_float","text":"","title":"int_bits_to_float"},{"location":"packs/other/Included-Flora/","text":"Terra comes packaged with many flora types that can be used out of the box. |ID|Description|Spawns On| |--|-----------|---------| |ALLIUM|Vanilla Allium|Grass Blocks and Podzol| |AZURE_BLUET|Vanilla Azure Bluet|Grass Blocks and Podzol| |BLUE_ORCHID|Vanilla Blue Orchid|Grass Blocks and Podzol| |BROWN_MUSHROOM|Vanilla Small Brown Mushroom|Grass Blocks, Podzol, Stone, Dirt, Netherrack| |CORNFLOWER|Vanilla Cornflower|Grass Blocks and Podzol| |DANDELION|Vanilla Dandelion|Grass Blocks and Podzol| |DEAD_BUSH|Vanilla Dead Bush|Grass Blocks, Podzol, Sand, Red Sand| |FERN|Vanilla Short Fern|Grass Blocks and Podzol| |GRASS|Vanilla Short Grass|Grass Blocks and Podzol| |LILAC|Vanilla Lilac|Grass Blocks and Podzol| |LILY_OF_THE_VALLEY|Vanilla Lily of the Valley|Grass Blocks and Podzol| |LILY_PAD|Vanilla Lily Pad|Water| |ORANGE_TULIP|Vanilla Orange Tulip|Grass Blocks and Podzol| |OXEYE_DAISY|Vanilla Oxeye Daisy|Grass Blocks and Podzol| |PEONY|Vanilla 2-block Peony|Grass Blocks and Podzol| |PINK_TULIP|Vanilla Pink Tulip|Grass Blocks and Podzol| |POPPY|Vanilla Poppy|Grass Blocks and Podzol| |RED_MUSHROOM|Vanilla Small Red Mushroom|Grass Blocks, Podzol, Stone, Dirt, Netherrack| |RED_TULIP|Vanilla Red Tulip|Grass Blocks and Podzol| |ROSE_BUSH|Vanilla 2-block Rose Bush|Grass Blocks and Podzol| |SUNFLOWER|Vanilla 2-block Sunflower|Grass Blocks and Podzol| |TALL_FERN|Vanilla 2-block Fern|Grass Blocks and Podzol| |TALL_GRASS|Vanilla 2-block Grass|Grass Blocks and Podzol| |WHITE_TULIP|Vanilla White Tulip|Grass Blocks and Podzol| |WITHER_ROSE|Vanilla Wither Rose|Grass Blocks and Podzol|","title":"Included Flora"},{"location":"packs/other/Noise-Options/","text":"Wherever you see a \"noise options\" section in your config, you can define a noise sampler there, using the following values: Noise Options \u00b6 type \u00b6 The type of sampler to use. Included samplers: * Linear - Linear normalizer. * Normal - Normal (normal -> continuous) normalizer. * Clamp - Clamp normalizer. * Expression - Paralithic expression noise function * Image - Pull noise from an image. * DomainWarp - Domain-warp a function with another function. * FBM - Fractal Brownian Motion. * PingPong - Ping Pong fractal type. * Ridged - Ridged fractal type. * OpenSimplex2 - OpenSimplex2 noise, regular variant. * OpenSimplex2S - OpenSimplex2 noise, smooth variant. * Perlin - Perlin noise. * Value - Gradient noise. * ValueCubic - Cubically interpolated gradient noise. * Cellular - Cellular (Voronoi/Worley) noise. * WhiteNoise - White (random) noise. * Gaussian - Gaussian (normally distributed random) noise. * Constant - Constant value. * Kernel - Apply a kernel to an input function. salt \u00b6 A value to add to the seed of the noise function. Noise functions are seeded with the world seed, adding a salt allows multiple otherwise identical noise functions to produce unique results in the same world. Default: 0 frequency \u00b6 The frequency of the noise function. Higher values = higher frequencies = quicker changes in noise values. Frequency has no effect on white noise (other than effectively being a second salt). Default: 0.02 dimensions \u00b6 Number of dimensions of this noise function. Must be either 2 or 3. Default: 2 Fractal Noise Types \u00b6 The following options are supported by all fractal noise types: * FBM * PingPong * Ridged octaves \u00b6 Defines the number of fractal octaves to generate. A fractal octave is a single noise function. For example, 5 octaves would create 5 noise functions stacked on top of each other. Default: 3 function \u00b6 Function to apply fractal to. gain \u00b6 Controls the fractal gain. The gain sets the amplitude multiplier of each subsequent noise function. For example, the default gain of 0.5 would cause an input noise function to have noise added with half the amplitude, then one quarter, then one eighth, etc. Default: 0.5 lacunarity \u00b6 Controls the fractal lacunarity. The lacunarity sets the frequency multiplier of each subsequent noise function. For example, the default lacunarity of 2.0 would cause the first octave to have the base frequency, the second to have 2 times the frequency, the third to have 4 times, etc. Default: 2.0 ping-pong \u00b6 Sets the strength of the \"ping-pong\" algorithm. Higher numbers will produce more defined stripes. Default: 2.0 weighted-strength \u00b6 Sets the weight of each octave. Higher values will cause octaves to produce higher weights at higher values. Note that values outside of [0, 1] will not maintain [-1, 1] output. Cellular Noise \u00b6 Options for the Cellular noise variant. distance \u00b6 distance sets the distance function to use for calculating the cell border. Supported distance functions: * Euclidean - Euclidean distance . * EuclideanSq - Calculate distance based on the square of Euclidean distances. This is faster than Euclidean (as it does not require a square root operation) and produces effectively the same result. * Manhattan - Manhattan ( Taxicab ) distance. * Hybrid - Average of EuclideanSq and Manhattan distances. Default: EuclideanSq return \u00b6 return sets the return type of the cellular noise function Supported return types: * CellValue - Returns the value of the cell itself. * Distance - Returns the distance to the nearest point. * Distance2 - Returns the distance to the second nearest point. * Distance3 - Returns the distance to the third nearest point. Distance2Add - D1 + D2 * Distance2Sub - D1 - D2 * Distance2Mul - D1 * D2 * Distance2Div - D1 / D2 * Distance3Add - D1 + D3 * Distance3Sub - D1 - D3 * Distance3Mul - D1 * D3 * Distance3Div - D1 / D3 NoiseLookup - Return the value of the cell's center point when passed into the lookup function. Default: Distance lookup \u00b6 lookup defines another noise function to use in the NoiseLookup return type. Default: OpenSimplex2 function with no fractal, and 0.02 frequency. Normalizer Options \u00b6 Options supported by all normalizer types: * Linear * Normal * Clamp function \u00b6 Function to normalize. Linear Options \u00b6 Linear redistribution redistributes the input from [min, max] to [-1, 1] . min \u00b6 Minimum input value max \u00b6 Maximum input value Normal Options \u00b6 Normal redistribution redistributes the input from a normal distribution with mean mean and standard deviation standard-deviation to a continuous distribution with range [-1, 1] . mean \u00b6 The mean of the input function. standard-deviation \u00b6 The standard deviation of the input function. Clamp Options \u00b6 The clamp normalizer clamps an arbitrarily ranged input function to a maximum/minimum value. Any value above the maximum will return the maximum, and any value below the minimum will return the minimum. min \u00b6 Minimum value max \u00b6 Maximum value DomainWarp Options \u00b6 function \u00b6 The source function. This function will be used to retrieve noise values. warp \u00b6 Function to use for domain warping. The result of this function will be added to the X, Y, and Z inputs of the function parameter. amplitude \u00b6 The amplitude of the domain warp. This value is the maximum an input point may be translated (provided that the warp function is bounded from [-1, 1] ) Image Options \u00b6 image \u00b6 The path of the image to use, relative to the config root. channel \u00b6 The channel to get values from. Valid channels are: * RED - Red channel of the image * GREEN - Green channel of the image * BLUE - Blue channel of the image * ALPHA - Alpha channel of the image * GRAYSCALE - Average of RED GREEN and BLUE channels. frequency \u00b6 The input coordinates are multiplied by this value, allowing for image scaling. Kernel Options \u00b6 kernel \u00b6 A 2D array representing the kernel to apply to the input function. Examples of common kernels . factor \u00b6 Factor to multiply all kernel values by. Useful for keeping kernels readable. Defaults to 1. function \u00b6 Noise function to apply the kernel to. Expression Options \u00b6 equation \u00b6 The equation to use for this noise function. The variables x , y , and z , along with any defined in the variables key, are registered, along with the noise functions defined in the functions key. functions \u00b6 A map of noise functions. These functions are registered for use in the equation. variables \u00b6 A map of variables. These variables are registered for use in the equation.","title":"Noise Options"},{"location":"packs/other/Noise-Options/#noise-options","text":"","title":"Noise Options"},{"location":"packs/other/Noise-Options/#type","text":"The type of sampler to use. Included samplers: * Linear - Linear normalizer. * Normal - Normal (normal -> continuous) normalizer. * Clamp - Clamp normalizer. * Expression - Paralithic expression noise function * Image - Pull noise from an image. * DomainWarp - Domain-warp a function with another function. * FBM - Fractal Brownian Motion. * PingPong - Ping Pong fractal type. * Ridged - Ridged fractal type. * OpenSimplex2 - OpenSimplex2 noise, regular variant. * OpenSimplex2S - OpenSimplex2 noise, smooth variant. * Perlin - Perlin noise. * Value - Gradient noise. * ValueCubic - Cubically interpolated gradient noise. * Cellular - Cellular (Voronoi/Worley) noise. * WhiteNoise - White (random) noise. * Gaussian - Gaussian (normally distributed random) noise. * Constant - Constant value. * Kernel - Apply a kernel to an input function.","title":"type"},{"location":"packs/other/Noise-Options/#salt","text":"A value to add to the seed of the noise function. Noise functions are seeded with the world seed, adding a salt allows multiple otherwise identical noise functions to produce unique results in the same world. Default: 0","title":"salt"},{"location":"packs/other/Noise-Options/#frequency","text":"The frequency of the noise function. Higher values = higher frequencies = quicker changes in noise values. Frequency has no effect on white noise (other than effectively being a second salt). Default: 0.02","title":"frequency"},{"location":"packs/other/Noise-Options/#dimensions","text":"Number of dimensions of this noise function. Must be either 2 or 3. Default: 2","title":"dimensions"},{"location":"packs/other/Noise-Options/#fractal-noise-types","text":"The following options are supported by all fractal noise types: * FBM * PingPong * Ridged","title":"Fractal Noise Types"},{"location":"packs/other/Noise-Options/#octaves","text":"Defines the number of fractal octaves to generate. A fractal octave is a single noise function. For example, 5 octaves would create 5 noise functions stacked on top of each other. Default: 3","title":"octaves"},{"location":"packs/other/Noise-Options/#function","text":"Function to apply fractal to.","title":"function"},{"location":"packs/other/Noise-Options/#gain","text":"Controls the fractal gain. The gain sets the amplitude multiplier of each subsequent noise function. For example, the default gain of 0.5 would cause an input noise function to have noise added with half the amplitude, then one quarter, then one eighth, etc. Default: 0.5","title":"gain"},{"location":"packs/other/Noise-Options/#lacunarity","text":"Controls the fractal lacunarity. The lacunarity sets the frequency multiplier of each subsequent noise function. For example, the default lacunarity of 2.0 would cause the first octave to have the base frequency, the second to have 2 times the frequency, the third to have 4 times, etc. Default: 2.0","title":"lacunarity"},{"location":"packs/other/Noise-Options/#ping-pong","text":"Sets the strength of the \"ping-pong\" algorithm. Higher numbers will produce more defined stripes. Default: 2.0","title":"ping-pong"},{"location":"packs/other/Noise-Options/#weighted-strength","text":"Sets the weight of each octave. Higher values will cause octaves to produce higher weights at higher values. Note that values outside of [0, 1] will not maintain [-1, 1] output.","title":"weighted-strength"},{"location":"packs/other/Noise-Options/#cellular-noise","text":"Options for the Cellular noise variant.","title":"Cellular Noise"},{"location":"packs/other/Noise-Options/#distance","text":"distance sets the distance function to use for calculating the cell border. Supported distance functions: * Euclidean - Euclidean distance . * EuclideanSq - Calculate distance based on the square of Euclidean distances. This is faster than Euclidean (as it does not require a square root operation) and produces effectively the same result. * Manhattan - Manhattan ( Taxicab ) distance. * Hybrid - Average of EuclideanSq and Manhattan distances. Default: EuclideanSq","title":"distance"},{"location":"packs/other/Noise-Options/#return","text":"return sets the return type of the cellular noise function Supported return types: * CellValue - Returns the value of the cell itself. * Distance - Returns the distance to the nearest point. * Distance2 - Returns the distance to the second nearest point. * Distance3 - Returns the distance to the third nearest point. Distance2Add - D1 + D2 * Distance2Sub - D1 - D2 * Distance2Mul - D1 * D2 * Distance2Div - D1 / D2 * Distance3Add - D1 + D3 * Distance3Sub - D1 - D3 * Distance3Mul - D1 * D3 * Distance3Div - D1 / D3 NoiseLookup - Return the value of the cell's center point when passed into the lookup function. Default: Distance","title":"return"},{"location":"packs/other/Noise-Options/#lookup","text":"lookup defines another noise function to use in the NoiseLookup return type. Default: OpenSimplex2 function with no fractal, and 0.02 frequency.","title":"lookup"},{"location":"packs/other/Noise-Options/#normalizer-options","text":"Options supported by all normalizer types: * Linear * Normal * Clamp","title":"Normalizer Options"},{"location":"packs/other/Noise-Options/#function_1","text":"Function to normalize.","title":"function"},{"location":"packs/other/Noise-Options/#linear-options","text":"Linear redistribution redistributes the input from [min, max] to [-1, 1] .","title":"Linear Options"},{"location":"packs/other/Noise-Options/#min","text":"Minimum input value","title":"min"},{"location":"packs/other/Noise-Options/#max","text":"Maximum input value","title":"max"},{"location":"packs/other/Noise-Options/#normal-options","text":"Normal redistribution redistributes the input from a normal distribution with mean mean and standard deviation standard-deviation to a continuous distribution with range [-1, 1] .","title":"Normal Options"},{"location":"packs/other/Noise-Options/#mean","text":"The mean of the input function.","title":"mean"},{"location":"packs/other/Noise-Options/#standard-deviation","text":"The standard deviation of the input function.","title":"standard-deviation"},{"location":"packs/other/Noise-Options/#clamp-options","text":"The clamp normalizer clamps an arbitrarily ranged input function to a maximum/minimum value. Any value above the maximum will return the maximum, and any value below the minimum will return the minimum.","title":"Clamp Options"},{"location":"packs/other/Noise-Options/#min_1","text":"Minimum value","title":"min"},{"location":"packs/other/Noise-Options/#max_1","text":"Maximum value","title":"max"},{"location":"packs/other/Noise-Options/#domainwarp-options","text":"","title":"DomainWarp Options"},{"location":"packs/other/Noise-Options/#function_2","text":"The source function. This function will be used to retrieve noise values.","title":"function"},{"location":"packs/other/Noise-Options/#warp","text":"Function to use for domain warping. The result of this function will be added to the X, Y, and Z inputs of the function parameter.","title":"warp"},{"location":"packs/other/Noise-Options/#amplitude","text":"The amplitude of the domain warp. This value is the maximum an input point may be translated (provided that the warp function is bounded from [-1, 1] )","title":"amplitude"},{"location":"packs/other/Noise-Options/#image-options","text":"","title":"Image Options"},{"location":"packs/other/Noise-Options/#image","text":"The path of the image to use, relative to the config root.","title":"image"},{"location":"packs/other/Noise-Options/#channel","text":"The channel to get values from. Valid channels are: * RED - Red channel of the image * GREEN - Green channel of the image * BLUE - Blue channel of the image * ALPHA - Alpha channel of the image * GRAYSCALE - Average of RED GREEN and BLUE channels.","title":"channel"},{"location":"packs/other/Noise-Options/#frequency_1","text":"The input coordinates are multiplied by this value, allowing for image scaling.","title":"frequency"},{"location":"packs/other/Noise-Options/#kernel-options","text":"","title":"Kernel Options"},{"location":"packs/other/Noise-Options/#kernel","text":"A 2D array representing the kernel to apply to the input function. Examples of common kernels .","title":"kernel"},{"location":"packs/other/Noise-Options/#factor","text":"Factor to multiply all kernel values by. Useful for keeping kernels readable. Defaults to 1.","title":"factor"},{"location":"packs/other/Noise-Options/#function_3","text":"Noise function to apply the kernel to.","title":"function"},{"location":"packs/other/Noise-Options/#expression-options","text":"","title":"Expression Options"},{"location":"packs/other/Noise-Options/#equation","text":"The equation to use for this noise function. The variables x , y , and z , along with any defined in the variables key, are registered, along with the noise functions defined in the functions key.","title":"equation"},{"location":"packs/other/Noise-Options/#functions","text":"A map of noise functions. These functions are registered for use in the equation.","title":"functions"},{"location":"packs/other/Noise-Options/#variables","text":"A map of variables. These variables are registered for use in the equation.","title":"variables"},{"location":"packs/other/Objects/","text":"This page details common values for all Terra objects. id \u00b6 The ID of this object. Any string will work as an ID, though it is generally recommended to use UPPER_SNAKE_CASE for object IDs. This value is required for all configs extends \u00b6 This key holds the ID of the object(s) this object extends. It is optional. If included, any abstractable keys missing from this object will be pulled from its super object(s). Super objects may be abstract or standard objects. Terra supports multi-level inheritance (i.e. A extends B, B extends C. In this scenario, A would pull options from itself first, then missing values from B, then still missing values from C). Terra also supports multiple inheritance (i.e. A extends B, C, D). In this scenario, A would pull from B (and its parents) first, then C (and its parents), etc. abstract \u00b6 This boolean key defines whether this object is abstract. An abstract object cannot be generated in the world. It holds config values to be used in multiple implementation objects. Abstract objects have the unique property of all config values being optional.","title":"Objects"},{"location":"packs/other/Objects/#id","text":"The ID of this object. Any string will work as an ID, though it is generally recommended to use UPPER_SNAKE_CASE for object IDs. This value is required for all configs","title":"id"},{"location":"packs/other/Objects/#extends","text":"This key holds the ID of the object(s) this object extends. It is optional. If included, any abstractable keys missing from this object will be pulled from its super object(s). Super objects may be abstract or standard objects. Terra supports multi-level inheritance (i.e. A extends B, B extends C. In this scenario, A would pull options from itself first, then missing values from B, then still missing values from C). Terra also supports multiple inheritance (i.e. A extends B, C, D). In this scenario, A would pull from B (and its parents) first, then C (and its parents), etc.","title":"extends"},{"location":"packs/other/Objects/#abstract","text":"This boolean key defines whether this object is abstract. An abstract object cannot be generated in the world. It holds config values to be used in multiple implementation objects. Abstract objects have the unique property of all config values being optional.","title":"abstract"},{"location":"packs/other/Terra-Tree-Types/","text":"Terra comes packaged with many tree types that can be used out of the box. ID Description ACACIA Vanilla Acacia tree BIRCH Vanilla Birch tree BROWN_MUSHROOM Vanilla Giant Brown Mushroom CACTUS Cactus, 1-4 blocks tall CHORUS_PLANT Vanilla Chorus Plant DARK_OAK Vanilla Dark Oak tree GIANT_OAK Giant procedurally generated Oak tree (From BetterEnd) GIANT_SPRUCE Giant procedurally generated Spruce tree (From BetterEnd) JUNGLE Vanilla Giant Jungle tree JUNGLE_COCOA Vanilla Jungle tree with Cocoa beans on it JUNGLE_BUSH Vanilla Jungle Shrub tree LARGE_OAK Vanilla Large Oak tree LARGE_SHATTERED_PILLAR Large Shattered End Pillar, may generate an End Crystal on top (From BetterEnd) LARGE_SPRUCE Vanilla Tall Spruce tree MEGA_SPRUCE Vanilla Mega Spruce tree OAK Vanilla Oak Tree RED_MUSHROOM Vanilla Giant Red Mushroom SHATTERED_LARGE Large Shattered Forest Tree (From BetterEnd) SHATTERED_SMALL Small Shattered Forest Tree (From BetterEnd) SMALL_JUNGLE Vanilla Small Jungle Tree SPRUCE Vanilla Spruce Tree SWAMP_OAK Vanilla Oak Tree with vines SMALL_SHATTERED_PILLAR Small Shattered End Pillar (From BetterEnd) TALL_BIRCH Vanilla Tall Birch Tree","title":"Terra Tree Types"},{"location":"packs/terrascript/TerraScript-Functions/","text":"Terra's TerraScript implementation contains many functions for interacting with the world, getting and setting data, and debugging. block \u00b6 The block function sets a block at a location. Arguments: Parameter Type Description x num X coordinate (relative to origin) to place block y num Y coordinate (relative to origin) to place block z num Z coordinate (relative to origin) to place block data str Block Data string to place (must be constant expression) replace bool Whether to replace an existing block. This is optional and defaults to true. When true, any block will be overwritten (this is the default behavior when this parameter is unspecified) When false, only air will be overwritten. Returns: VOID check \u00b6 The check function checks the \"type\" of a location. It is a fast way to tell whether a location is in the air, ocean, or ground. While it cannot provide specific block state information, it is much faster than getBlock , and does not force-load chunks it is used in. It is recommended to avoid getBlock in regular structures, and use check whenever possible. Arguments: Parameter Type Description x num X coordinate (relative to origin) to check y num Y coordinate (relative to origin) to check z num Z coordinate (relative to origin) to check Returns: STRING - The type of the location at the parameter coordinates, added to the structure origin. Must be one of: * AIR - The location is air. * LAND - The location is in the land. * OCEAN - The location is in the ocean. structure \u00b6 The structure function generates another structure within the current structure, with an offset origin and rotation. Arguments: Parameter Type Description x num X coordinate (relative to origin) to place structure y num Y coordinate (relative to origin) to place structure z num Z coordinate (relative to origin) to place structure structure str ID of structure to generate (equal to the id statement of that structure's script) rotation str... Rotations to generate this structure with. One of these rotations will be randomly selected. Valid rotations are: NONE (No rotation), CW_90 (Clockwise 90 degrees), CCW_90 (Counterclockwise 90 degrees), and CW_180 (180 degrees) * ... in the rotation parameter type description means that it is a vararg parameter - it may contain any number of values. Returns: BOOlEAN - true if structure successfully generated, false if generation failed. randomInt \u00b6 The randomInt function returns a random value within a range. Arguments: Parameter Type Description range num Maximum value (exclusive) Returns: NUMBER - A random integer (whole number) between 0 (inclusive) and range (exclusive). For example, randomInt(10) would return a number from 0 to 9 . recursions \u00b6 The recursions function gets the number of recursions that have occurred prior to the generation of the structure. It is incredibly useful for preventing infinite recursion in recursive structures. Arguments: none Returns: NUMBER - The number of recursions that have occurred. If structure_a is generates structure_b via the structure function, recursions() would return 0 in structure_a , then 1 in structure_b . If structure_b then generated structure_a again, recursions() would return 2 in the second instance of structure_a only . setMark \u00b6 The setMark function is one of two functions for interacting with Marks, which allow data to be stored in structures and accessed later, without affecting generation. A Mark is a string assigned to a location in a structure. It is set by the setMark function, and then can be retrieved by the getMark function. One possible use case includes marking locations where structures generate, then checking them with getMark to ensure structures do not overlap. Marks set in recursive structures are visible by parent structures. if structure_a generates structure_b via the structure function, and structure_b sets a mark, structure_a can retrieve that mark. Marks are set relative to the added origins of all recursions. Setting a mark that already exists will overwrite it with a new value. Arguments: Parameter Type Description x num X coordinate (relative to origin) to set mark y num Y coordinate (relative to origin) to set mark z num Z coordinate (relative to origin) to set mark content str Content of the mark to place Returns: VOID getMark \u00b6 The getMark function is one of two functions for interacting with Marks, which allow data to be stored in structures and accessed later, without affecting generation. A Mark is a string assigned to a location in a structure. It is set by the setMark function, and then can be retrieved by the getMark function. One possible use case includes marking locations where structures generate, then checking them with getMark to ensure structures do not overlap. Marks set in recursive structures are visible by parent structures. if structure_a generates structure_b via the structure function, and structure_b sets a mark, structure_a can retrieve that mark. Marks are set relative to the added origins of all recursions. Arguments: Parameter Type Description x num X coordinate (relative to origin) to check mark y num Y coordinate (relative to origin) to check mark z num Z coordinate (relative to origin) to check mark Returns: STRING - The content of the mark at the location. Returns \"\" (empty string) if the mark is empty or not present. pull \u00b6 The pull function sets a block at a location, then \"pulls\" it down to ground. The pull function will search at the specified location, then downwards, until the block is not air. Arguments: Parameter Type Description x num X coordinate (relative to origin) to place block y num Y coordinate (relative to origin) to start search z num Z coordinate (relative to origin) to place block data str Block Data string to place (must be constant expression) Returns: VOID loot \u00b6 The loot function populates a container with loot. A container is any block with an inventory (chests, shulker boxes, furnaces, brewing stands, etc.) Arguments: Parameter Type Description x num X coordinate (relative to origin) to fill loot y num Y coordinate (relative to origin) to fill loot z num Z coordinate (relative to origin) to fill loot table str Filename of the loot table, relative to pack/structures/loot . Example: village/village_house.json Returns: VOID entity \u00b6 The entity function spawns an entity at a location. Arguments: Parameter Type Description x num X coordinate (relative to origin) to spawn entity y num Y coordinate (relative to origin) to spawn entity z num Z coordinate (relative to origin) to spawn entity entity str Entity ID to spawn Returns: VOID getBiome \u00b6 The getBiome function gets the Terra biome at a location. Arguments: Parameter Type Description x num X coordinate (relative to origin) to check biome y num Y coordinate (relative to origin) to check biome z num Z coordinate (relative to origin) to check biome Returns: STRING - The ID of the biome, E.G. \"ARID_MOUNTAINS\" . getBlock \u00b6 The getBlock function checks the Block State at a location. It should NOT be used in regular structures! The getBlock function force-loads chunks when it runs. This is fine in trees, which load chunks anyways, but in regular structures it will cause cascading chunk loading whenever a structure generates. Use the check function instead in regular structures! Arguments: Parameter Type Description x num X coordinate (relative to origin) to check block y num Y coordinate (relative to origin) to check block z num Z coordinate (relative to origin) to check block Returns: STRING - The ID of the block, without properties, E.G. \"minecraft:stone\" . state \u00b6 The state function manipulates NBT data on block entities (like signs and mob spawners). Data is formatted as \"key1=value1,key2=value2\" . E.G. \"text1=hello,text2=world\" applied to a sign would cause the sign to read: hello world Arguments: Parameter Type Description x num X coordinate (relative to origin) of block y num Y coordinate (relative to origin) of block z num Z coordinate (relative to origin) of block data str Data to apply to block Returns: VOID print \u00b6 The print function prints a string to the console. It is a debug function, and as such will only work with debug mode enabled. Arguments: Parameter Type Description message str Message to print to console Returns: VOID","title":"Terrascript"},{"location":"packs/terrascript/TerraScript-Functions/#block","text":"The block function sets a block at a location. Arguments: Parameter Type Description x num X coordinate (relative to origin) to place block y num Y coordinate (relative to origin) to place block z num Z coordinate (relative to origin) to place block data str Block Data string to place (must be constant expression) replace bool Whether to replace an existing block. This is optional and defaults to true. When true, any block will be overwritten (this is the default behavior when this parameter is unspecified) When false, only air will be overwritten. Returns: VOID","title":"block"},{"location":"packs/terrascript/TerraScript-Functions/#check","text":"The check function checks the \"type\" of a location. It is a fast way to tell whether a location is in the air, ocean, or ground. While it cannot provide specific block state information, it is much faster than getBlock , and does not force-load chunks it is used in. It is recommended to avoid getBlock in regular structures, and use check whenever possible. Arguments: Parameter Type Description x num X coordinate (relative to origin) to check y num Y coordinate (relative to origin) to check z num Z coordinate (relative to origin) to check Returns: STRING - The type of the location at the parameter coordinates, added to the structure origin. Must be one of: * AIR - The location is air. * LAND - The location is in the land. * OCEAN - The location is in the ocean.","title":"check"},{"location":"packs/terrascript/TerraScript-Functions/#structure","text":"The structure function generates another structure within the current structure, with an offset origin and rotation. Arguments: Parameter Type Description x num X coordinate (relative to origin) to place structure y num Y coordinate (relative to origin) to place structure z num Z coordinate (relative to origin) to place structure structure str ID of structure to generate (equal to the id statement of that structure's script) rotation str... Rotations to generate this structure with. One of these rotations will be randomly selected. Valid rotations are: NONE (No rotation), CW_90 (Clockwise 90 degrees), CCW_90 (Counterclockwise 90 degrees), and CW_180 (180 degrees) * ... in the rotation parameter type description means that it is a vararg parameter - it may contain any number of values. Returns: BOOlEAN - true if structure successfully generated, false if generation failed.","title":"structure"},{"location":"packs/terrascript/TerraScript-Functions/#randomint","text":"The randomInt function returns a random value within a range. Arguments: Parameter Type Description range num Maximum value (exclusive) Returns: NUMBER - A random integer (whole number) between 0 (inclusive) and range (exclusive). For example, randomInt(10) would return a number from 0 to 9 .","title":"randomInt"},{"location":"packs/terrascript/TerraScript-Functions/#recursions","text":"The recursions function gets the number of recursions that have occurred prior to the generation of the structure. It is incredibly useful for preventing infinite recursion in recursive structures. Arguments: none Returns: NUMBER - The number of recursions that have occurred. If structure_a is generates structure_b via the structure function, recursions() would return 0 in structure_a , then 1 in structure_b . If structure_b then generated structure_a again, recursions() would return 2 in the second instance of structure_a only .","title":"recursions"},{"location":"packs/terrascript/TerraScript-Functions/#setmark","text":"The setMark function is one of two functions for interacting with Marks, which allow data to be stored in structures and accessed later, without affecting generation. A Mark is a string assigned to a location in a structure. It is set by the setMark function, and then can be retrieved by the getMark function. One possible use case includes marking locations where structures generate, then checking them with getMark to ensure structures do not overlap. Marks set in recursive structures are visible by parent structures. if structure_a generates structure_b via the structure function, and structure_b sets a mark, structure_a can retrieve that mark. Marks are set relative to the added origins of all recursions. Setting a mark that already exists will overwrite it with a new value. Arguments: Parameter Type Description x num X coordinate (relative to origin) to set mark y num Y coordinate (relative to origin) to set mark z num Z coordinate (relative to origin) to set mark content str Content of the mark to place Returns: VOID","title":"setMark"},{"location":"packs/terrascript/TerraScript-Functions/#getmark","text":"The getMark function is one of two functions for interacting with Marks, which allow data to be stored in structures and accessed later, without affecting generation. A Mark is a string assigned to a location in a structure. It is set by the setMark function, and then can be retrieved by the getMark function. One possible use case includes marking locations where structures generate, then checking them with getMark to ensure structures do not overlap. Marks set in recursive structures are visible by parent structures. if structure_a generates structure_b via the structure function, and structure_b sets a mark, structure_a can retrieve that mark. Marks are set relative to the added origins of all recursions. Arguments: Parameter Type Description x num X coordinate (relative to origin) to check mark y num Y coordinate (relative to origin) to check mark z num Z coordinate (relative to origin) to check mark Returns: STRING - The content of the mark at the location. Returns \"\" (empty string) if the mark is empty or not present.","title":"getMark"},{"location":"packs/terrascript/TerraScript-Functions/#pull","text":"The pull function sets a block at a location, then \"pulls\" it down to ground. The pull function will search at the specified location, then downwards, until the block is not air. Arguments: Parameter Type Description x num X coordinate (relative to origin) to place block y num Y coordinate (relative to origin) to start search z num Z coordinate (relative to origin) to place block data str Block Data string to place (must be constant expression) Returns: VOID","title":"pull"},{"location":"packs/terrascript/TerraScript-Functions/#loot","text":"The loot function populates a container with loot. A container is any block with an inventory (chests, shulker boxes, furnaces, brewing stands, etc.) Arguments: Parameter Type Description x num X coordinate (relative to origin) to fill loot y num Y coordinate (relative to origin) to fill loot z num Z coordinate (relative to origin) to fill loot table str Filename of the loot table, relative to pack/structures/loot . Example: village/village_house.json Returns: VOID","title":"loot"},{"location":"packs/terrascript/TerraScript-Functions/#entity","text":"The entity function spawns an entity at a location. Arguments: Parameter Type Description x num X coordinate (relative to origin) to spawn entity y num Y coordinate (relative to origin) to spawn entity z num Z coordinate (relative to origin) to spawn entity entity str Entity ID to spawn Returns: VOID","title":"entity"},{"location":"packs/terrascript/TerraScript-Functions/#getbiome","text":"The getBiome function gets the Terra biome at a location. Arguments: Parameter Type Description x num X coordinate (relative to origin) to check biome y num Y coordinate (relative to origin) to check biome z num Z coordinate (relative to origin) to check biome Returns: STRING - The ID of the biome, E.G. \"ARID_MOUNTAINS\" .","title":"getBiome"},{"location":"packs/terrascript/TerraScript-Functions/#getblock","text":"The getBlock function checks the Block State at a location. It should NOT be used in regular structures! The getBlock function force-loads chunks when it runs. This is fine in trees, which load chunks anyways, but in regular structures it will cause cascading chunk loading whenever a structure generates. Use the check function instead in regular structures! Arguments: Parameter Type Description x num X coordinate (relative to origin) to check block y num Y coordinate (relative to origin) to check block z num Z coordinate (relative to origin) to check block Returns: STRING - The ID of the block, without properties, E.G. \"minecraft:stone\" .","title":"getBlock"},{"location":"packs/terrascript/TerraScript-Functions/#state","text":"The state function manipulates NBT data on block entities (like signs and mob spawners). Data is formatted as \"key1=value1,key2=value2\" . E.G. \"text1=hello,text2=world\" applied to a sign would cause the sign to read: hello world Arguments: Parameter Type Description x num X coordinate (relative to origin) of block y num Y coordinate (relative to origin) of block z num Z coordinate (relative to origin) of block data str Data to apply to block Returns: VOID","title":"state"},{"location":"packs/terrascript/TerraScript-Functions/#print","text":"The print function prints a string to the console. It is a debug function, and as such will only work with debug mode enabled. Arguments: Parameter Type Description message str Message to print to console Returns: VOID","title":"print"},{"location":"packs/terrascript/TerraScript-Syntax/","text":"TerraScript syntax is very similar to JavaScript and other C-like syntax languages. If you have worked with such languages, TerraScript will feel very familiar. If not, TerraScript is still very simple to learn! ID \u00b6 Each script must begin with an id statement. An ID statement has the following syntax: id \"identifier\" ; The identifier portion must be a unique string. It will be used to identify the script in configs. Functions \u00b6 A function is an expression that performs an action using arguments , and (optionally) returns a value. Function Basics \u00b6 Functions in TerraScript look like this: function(arg1, arg2); function is the function's identifier (the function name), arg1 and arg2 are arguments (data given to the function for it to operate on). See the Functions page for information on TerraScript functions implemented in Terra. Return Types \u00b6 In the Functions documentation, each function has a return type of either void , num , str or bool . return simply means the function \"gives back\" a value when it finishes executing. That value can be ignored, or used in expressions, such as variable assignments, comparisons, or even other function calls. A return type of num , str or bool simply means that the function returns a numeric, string, or boolean value. This value can be used in any expression requiring something matching its data type. A return type of void means that the function does not return a value. void functions cannot be assigned to variables or used in expressions. Expressions \u00b6 An expression is a series of tokens that may be evaluated to produce a value. An example is 5 + 3 * 2 , which evaluates to 11 . Types \u00b6 Before we get into expressions, we must first discuss types. A type is the \"type\" of data required/provided by something in TerraScript. Every expression in TerraScript has a type. TerraScript is a statically-typed language, meaning that type checking is done at the time of parsing, rather than execution. This means that you don't need to worry about checking the type of your variables at runtime. Terra has 3 types, which have been introduced above: * num - A numeric value. Num may hold decimal or integer values. It may be compared to other num s via comparison operators. * bool - A boolean value. Booleans can either be true or false. It may be compared to other bool s via boolean operators. * str - A string value. Strings hold sequences of characters, i.e. \"Hello, World!\" It may be compared to other str s via the equals and not equals operators. ( void is not technically a type, it simply marks that a function does not return a value.) Constant Expressions \u00b6 Constant expressions are expressions that hold a constant value of a certain type. * str constant expressions are surrounded by double quotes: \"This is a constant string\" * num constant expressions are raw numeric values: 0 , 1 , 20.3 , 42.0 * bool constant expressions are simply the keyword true or false Compound Expressions \u00b6 Compound Expressions are multiple expressions combined using operators . TerraScript contains many operators to perform operations on different data types. Operators \u00b6 Operators are constructs which perform an operation on one or more piece of data. Number Operators \u00b6 + - Adds two numbers. - - Subtracts the right number from the left number. * - Multiplies two numbers. / - Divides the left number by the right number. % - Computes the nth modulus of the left number, where n is the right number. Boolean Operators \u00b6 && - Boolean AND (if left AND right are true, evaluates true) || - Boolean OR (if left OR right are true, evaluates true) Comparison operators \u00b6 > - Less than - Compares 2 numbers. < - Greater than - Compares 2 numbers. >= - Less than or equal to - Compares 2 numbers. <= - Greater than or equal to = Compares 2 numbers. == - Equal to - Compares any data types. != - Not equal to - Compares any data types. Unary Operators \u00b6 Unary operators are operators which operate on only one piece of data. * ! - Boolean NOT operator. !true = false, !false = true. * - - Negation operator. -(1) = -1, -(-1) = 1. Functions \u00b6 Functions that return values are expressions! The return value of a function may be used in a compound expression by simply placing the function within the expression, like so: randomInt ( 5 ) * 2 > 3 ; // Evaluates to true if a random integer between 0 and 5 multiplied by 2 is greater than 3. Variables \u00b6 Variables are used to hold data. They are declared with a name called an identifier , which can be used in assignments and references . Declaration \u00b6 To create a variable it must be declared . Declaration of variables in Terra follows a very standard syntax: type identifier = value; type is the type of the variable, either str , bool , or num . identifier is the identifier (name) to give the variable. value is the value to assign to the variable. A variable's value may be any expression that matches its declared type. Example: num aNumber = 0 ; // Declare a num variable called aNumber with value 0. str example = \"hello, world\" ; // Declare a str variable called example with a value of \"hello, world\". bool condition = false ; // Declare a boolean variable called condition with a value of false. References \u00b6 Variables can be used in expressions with references . To reference a variable, simply include it's identifier in an expression. The identifier evaluates to the value the variable contains. Example: num number = 3 ; print ( \"Number: \" + number ); // Prints Number: 3 Assignments \u00b6 The value of a variable can be updated with assignments . A declaration includes an assingment. To re-assign a variable after declaration, use the syntax identifier = value; . You cannot re- declare variables, you must re- assign them. Example: num aNumber = 0 ; print ( \"Number: \" + number ); // Prints Number: 0 aNumber = 3 ; print ( \"Number: \" + number ); // Prints Number: 3 The value is declared and initialized to 0 . Then, after the first print statement, the variable is re-assigned to have a value of 3. You can even reference a variable in its own re-assignment: num aNumber = 4 ; print ( \"Number: \" + number ); // Prints Number: 4 aNumber = aNumber - 1 ; // Set aNumber to itself, minus one. print ( \"Number: \" + number ); // Prints Number: 3 Conditional Statements \u00b6 A key part of any programming language are conditional statements. TerraScript has a very standard if , else if else syntax. if \u00b6 The if statement evaluates a block of code if a condition evaluates true. if ( condition ) { print ( \"condition is true\" ); } In the above example, the print function would only be run if condition is equal to true. We assume that condition is a bool . Any other data type would not be allowed by the parser. Comparisons \u00b6 Making comparisons with data allows if statements to become very powerful. TerraScript supports six comparison operators, listed above. These operators are all binary operators , meaning they operate between 2 expressions. E.G. 5 > 1 returns true . Equal to and not equal to can be used between any data types. The rest are strictly between two num s. Combined with the if statement we get this: if ( 5 > 1 ) { print ( \"condition is true\" ); } This isn't very useful, though. That condition is always true! What if we use randomInt instead? if ( randomInt ( 2 ) == 0 ) { print ( \"This message prints half the time!\" ); } With external conditions introduced, the script can now have different behavior in different situations. else \u00b6 What if we want to do thing a half the time, and thing b the rest of the time? We could do something like this: num randomNumber = randomInt ( 2 ); if ( randomNumber == 0 ) { print ( \"This message prints half the time!\" ); } if ( randomNumber == 1 ) { print ( \"This message prints the other half the time!\" ); } That's ugly, though. There's a much cleaner and more readable way to do the same thing, which is to use the else statement. else statements go after if statements, and evaluate only if the if condition is false. Rewriting the above example with else looks like this: if ( randomInt ( 2 ) == 0 ) { print ( \"This message prints half the time!\" ); } else { print ( \"This message prints the other half the time!\" ); } That's much cleaner than before. We can even reduce this further, since each block contains just one expression we can use a single-expression statement: if ( randomInt ( 2 ) == 0 ) print ( \"This message prints half the time!\" ); else print ( \"This message prints the other half the time!\" ); Notice the absence of curly braces. You can only do this if there is a single expression in your statement/loop. else if \u00b6 Well, what if we want more conditions? We can use else if statements to add more conditions. They will be evaluated sequentially, and evaluation will stop after one is true. num randomNumber = randomInt ( 3 ); if ( randomNumber == 0 ) print ( \"This message prints one-third of the time!\" ); else if ( randomNumber == 1 ) print ( \"This message prints another third of the time!\" ); else if ( randomNumber == 2 ) print ( \"This message prints *another* third of the time!\" ); Using else if statements, we can make our scripts more readable and concise. else if can also be paired with else , like so: num randomNumber = randomInt ( 3 ); if ( randomNumber == 0 ) print ( \"This message prints one-third of the time!\" ); else if ( randomNumber == 1 ) print ( \"This message prints another third of the time!\" ); else print ( \"This message prints *another* third of the time!\" ); Loops \u00b6 Loops allow you to run a block of code repeatedly, based on a condition. While Loop \u00b6 The simplest loop is the While Loop. A while loop takes a single boolean expression, called a conditional expression, in its declaration. The block declared with the while loop will be run if the condition is true, then will continue to run until the condition is false. Examples: while ( true ) { // Since the condition is always true, the block will run infinitely. You generally want to avoid situations like this. print ( \"this runs forever!\" ); } The loop in this example runs forever, which is generally undesirable. num aNumber = 0 ; while ( number < 5 ) { // This will run the block until aNumber is NOT less than 5 (until A is greater than or equal to 5). print ( \"Number: \" + aNumber ); aNumber = aNumber + 1 ; // Add one to aNumber each time the loop runs. } This loop will run 5 times. The console output would be: Number: 0 Number: 1 Number: 2 Number: 3 Number: 4 For Loop \u00b6 The For Loop is similar to a while loop, but with 3 expressions in its declaration. Example: for ( num x = 0 ; x < 5 ; x = x + 1 ) { print ( \"Number: \" + aNumber ); } This loop does the same thing as the while loop above; it prints numbers from 0-4. It can be read as \"declare a variable called X, loop as long as x is less than 5, add 1 to x evey time.\" For Loop Expressions: \u00b6 Initializer \u00b6 The first expression in the for loop is called the initializer. Usually this is a variable declaration. In the case of a variable declaration initializer, that variable is available only within the scope of the loop. An example is num x = 0 in the above example, which declares a number variable with identifier x that may be referenced in the loop's scope. Conditional \u00b6 The second expression in the for loop is called the conditional. It is identical to the conditional in the while loop; the loop will run so long as it is true, once it is false the loop will stop. Usually, if a variable was declared in the initializer, the conditional checks a comparison of the variable. In the example above, the conditional checks that x is less than 5. Incrementer \u00b6 The third statement in the loop is called the incrementer. The incrementer is run at the end of every loop iteration, after the entire block is executed, before the next conditional check is made. Usually the incrementer is used to increment a variable. In the example above, the incrementer adds 1 to x every iteration. Flow Control \u00b6 TerraScript includes 4 Flow Control keywords: return \u00b6 The return keyword immediately halts execution of the script with \"passing\" exit status. It may be used in the base block, or in loops. Example: print ( \"This will be printed!\" ); return ; // Halt execution here. print ( \"This will never be printed!\" ); The above example exits with passing status after printing the first message. The second message will never be printed. fail \u00b6 The fail keyword immediately halts execution of the script with a \"failure\" exit status. It may be used in the base block, or in loops. Example: print ( \"This will be printed!\" ); fail ; // Halt execution here. print ( \"This will never be printed!\" ); The above example exits with failing status after printing the first message. The second message will never be printed. It is important to remember that both return and fail cascade, meaning that if they are used in loops they will immediately exit all parent loops and halt the script. break \u00b6 The break keyword immediately halts the execution of a loop. It will immediately exit the loop, resuming execution after the loop. Since it is a loop control keyword, it may only be used in loops. Example: num aNumber = 0 ; while ( true ) { // This loop would normally be infinite. if ( aNumber > 5 ) break ; // Halt the loop if aNumber is greater than 5 print ( \"Number:\" + aNumber ); aNumber = aNumber + 1 ; } The following loop would execute until aNumber is greater than 5, then it would halt and resume execution of the rest of the script. continue \u00b6 The continue keyword immediately halts the current iteration of a loop. It will stop the current exexution, and go to the head of the loop, then continue the loop (if the conditional is met). Example: num aNumber = 0 ; while ( aNumber <= 5 ) { // This loop would normally be infinite. aNumber = aNumber + 1 ; print ( \"Number:\" + aNumber ); if ( aNumber > 2 ) continue ; // Go back to top if number is greater than 2 print ( \"Less than 2\" ); } The following loop would execute until aNumber is greater than 5, and prints \"Less than 2\" every time it is less than 2.","title":"TerraScript Syntax"},{"location":"packs/terrascript/TerraScript-Syntax/#id","text":"Each script must begin with an id statement. An ID statement has the following syntax: id \"identifier\" ; The identifier portion must be a unique string. It will be used to identify the script in configs.","title":"ID"},{"location":"packs/terrascript/TerraScript-Syntax/#functions","text":"A function is an expression that performs an action using arguments , and (optionally) returns a value.","title":"Functions"},{"location":"packs/terrascript/TerraScript-Syntax/#function-basics","text":"Functions in TerraScript look like this: function(arg1, arg2); function is the function's identifier (the function name), arg1 and arg2 are arguments (data given to the function for it to operate on). See the Functions page for information on TerraScript functions implemented in Terra.","title":"Function Basics"},{"location":"packs/terrascript/TerraScript-Syntax/#return-types","text":"In the Functions documentation, each function has a return type of either void , num , str or bool . return simply means the function \"gives back\" a value when it finishes executing. That value can be ignored, or used in expressions, such as variable assignments, comparisons, or even other function calls. A return type of num , str or bool simply means that the function returns a numeric, string, or boolean value. This value can be used in any expression requiring something matching its data type. A return type of void means that the function does not return a value. void functions cannot be assigned to variables or used in expressions.","title":"Return Types"},{"location":"packs/terrascript/TerraScript-Syntax/#expressions","text":"An expression is a series of tokens that may be evaluated to produce a value. An example is 5 + 3 * 2 , which evaluates to 11 .","title":"Expressions"},{"location":"packs/terrascript/TerraScript-Syntax/#types","text":"Before we get into expressions, we must first discuss types. A type is the \"type\" of data required/provided by something in TerraScript. Every expression in TerraScript has a type. TerraScript is a statically-typed language, meaning that type checking is done at the time of parsing, rather than execution. This means that you don't need to worry about checking the type of your variables at runtime. Terra has 3 types, which have been introduced above: * num - A numeric value. Num may hold decimal or integer values. It may be compared to other num s via comparison operators. * bool - A boolean value. Booleans can either be true or false. It may be compared to other bool s via boolean operators. * str - A string value. Strings hold sequences of characters, i.e. \"Hello, World!\" It may be compared to other str s via the equals and not equals operators. ( void is not technically a type, it simply marks that a function does not return a value.)","title":"Types"},{"location":"packs/terrascript/TerraScript-Syntax/#constant-expressions","text":"Constant expressions are expressions that hold a constant value of a certain type. * str constant expressions are surrounded by double quotes: \"This is a constant string\" * num constant expressions are raw numeric values: 0 , 1 , 20.3 , 42.0 * bool constant expressions are simply the keyword true or false","title":"Constant Expressions"},{"location":"packs/terrascript/TerraScript-Syntax/#compound-expressions","text":"Compound Expressions are multiple expressions combined using operators . TerraScript contains many operators to perform operations on different data types.","title":"Compound Expressions"},{"location":"packs/terrascript/TerraScript-Syntax/#operators","text":"Operators are constructs which perform an operation on one or more piece of data.","title":"Operators"},{"location":"packs/terrascript/TerraScript-Syntax/#number-operators","text":"+ - Adds two numbers. - - Subtracts the right number from the left number. * - Multiplies two numbers. / - Divides the left number by the right number. % - Computes the nth modulus of the left number, where n is the right number.","title":"Number Operators"},{"location":"packs/terrascript/TerraScript-Syntax/#boolean-operators","text":"&& - Boolean AND (if left AND right are true, evaluates true) || - Boolean OR (if left OR right are true, evaluates true)","title":"Boolean Operators"},{"location":"packs/terrascript/TerraScript-Syntax/#comparison-operators","text":"> - Less than - Compares 2 numbers. < - Greater than - Compares 2 numbers. >= - Less than or equal to - Compares 2 numbers. <= - Greater than or equal to = Compares 2 numbers. == - Equal to - Compares any data types. != - Not equal to - Compares any data types.","title":"Comparison operators"},{"location":"packs/terrascript/TerraScript-Syntax/#unary-operators","text":"Unary operators are operators which operate on only one piece of data. * ! - Boolean NOT operator. !true = false, !false = true. * - - Negation operator. -(1) = -1, -(-1) = 1.","title":"Unary Operators"},{"location":"packs/terrascript/TerraScript-Syntax/#functions_1","text":"Functions that return values are expressions! The return value of a function may be used in a compound expression by simply placing the function within the expression, like so: randomInt ( 5 ) * 2 > 3 ; // Evaluates to true if a random integer between 0 and 5 multiplied by 2 is greater than 3.","title":"Functions"},{"location":"packs/terrascript/TerraScript-Syntax/#variables","text":"Variables are used to hold data. They are declared with a name called an identifier , which can be used in assignments and references .","title":"Variables"},{"location":"packs/terrascript/TerraScript-Syntax/#declaration","text":"To create a variable it must be declared . Declaration of variables in Terra follows a very standard syntax: type identifier = value; type is the type of the variable, either str , bool , or num . identifier is the identifier (name) to give the variable. value is the value to assign to the variable. A variable's value may be any expression that matches its declared type. Example: num aNumber = 0 ; // Declare a num variable called aNumber with value 0. str example = \"hello, world\" ; // Declare a str variable called example with a value of \"hello, world\". bool condition = false ; // Declare a boolean variable called condition with a value of false.","title":"Declaration"},{"location":"packs/terrascript/TerraScript-Syntax/#references","text":"Variables can be used in expressions with references . To reference a variable, simply include it's identifier in an expression. The identifier evaluates to the value the variable contains. Example: num number = 3 ; print ( \"Number: \" + number ); // Prints Number: 3","title":"References"},{"location":"packs/terrascript/TerraScript-Syntax/#assignments","text":"The value of a variable can be updated with assignments . A declaration includes an assingment. To re-assign a variable after declaration, use the syntax identifier = value; . You cannot re- declare variables, you must re- assign them. Example: num aNumber = 0 ; print ( \"Number: \" + number ); // Prints Number: 0 aNumber = 3 ; print ( \"Number: \" + number ); // Prints Number: 3 The value is declared and initialized to 0 . Then, after the first print statement, the variable is re-assigned to have a value of 3. You can even reference a variable in its own re-assignment: num aNumber = 4 ; print ( \"Number: \" + number ); // Prints Number: 4 aNumber = aNumber - 1 ; // Set aNumber to itself, minus one. print ( \"Number: \" + number ); // Prints Number: 3","title":"Assignments"},{"location":"packs/terrascript/TerraScript-Syntax/#conditional-statements","text":"A key part of any programming language are conditional statements. TerraScript has a very standard if , else if else syntax.","title":"Conditional Statements"},{"location":"packs/terrascript/TerraScript-Syntax/#if","text":"The if statement evaluates a block of code if a condition evaluates true. if ( condition ) { print ( \"condition is true\" ); } In the above example, the print function would only be run if condition is equal to true. We assume that condition is a bool . Any other data type would not be allowed by the parser.","title":"if"},{"location":"packs/terrascript/TerraScript-Syntax/#comparisons","text":"Making comparisons with data allows if statements to become very powerful. TerraScript supports six comparison operators, listed above. These operators are all binary operators , meaning they operate between 2 expressions. E.G. 5 > 1 returns true . Equal to and not equal to can be used between any data types. The rest are strictly between two num s. Combined with the if statement we get this: if ( 5 > 1 ) { print ( \"condition is true\" ); } This isn't very useful, though. That condition is always true! What if we use randomInt instead? if ( randomInt ( 2 ) == 0 ) { print ( \"This message prints half the time!\" ); } With external conditions introduced, the script can now have different behavior in different situations.","title":"Comparisons"},{"location":"packs/terrascript/TerraScript-Syntax/#else","text":"What if we want to do thing a half the time, and thing b the rest of the time? We could do something like this: num randomNumber = randomInt ( 2 ); if ( randomNumber == 0 ) { print ( \"This message prints half the time!\" ); } if ( randomNumber == 1 ) { print ( \"This message prints the other half the time!\" ); } That's ugly, though. There's a much cleaner and more readable way to do the same thing, which is to use the else statement. else statements go after if statements, and evaluate only if the if condition is false. Rewriting the above example with else looks like this: if ( randomInt ( 2 ) == 0 ) { print ( \"This message prints half the time!\" ); } else { print ( \"This message prints the other half the time!\" ); } That's much cleaner than before. We can even reduce this further, since each block contains just one expression we can use a single-expression statement: if ( randomInt ( 2 ) == 0 ) print ( \"This message prints half the time!\" ); else print ( \"This message prints the other half the time!\" ); Notice the absence of curly braces. You can only do this if there is a single expression in your statement/loop.","title":"else"},{"location":"packs/terrascript/TerraScript-Syntax/#else-if","text":"Well, what if we want more conditions? We can use else if statements to add more conditions. They will be evaluated sequentially, and evaluation will stop after one is true. num randomNumber = randomInt ( 3 ); if ( randomNumber == 0 ) print ( \"This message prints one-third of the time!\" ); else if ( randomNumber == 1 ) print ( \"This message prints another third of the time!\" ); else if ( randomNumber == 2 ) print ( \"This message prints *another* third of the time!\" ); Using else if statements, we can make our scripts more readable and concise. else if can also be paired with else , like so: num randomNumber = randomInt ( 3 ); if ( randomNumber == 0 ) print ( \"This message prints one-third of the time!\" ); else if ( randomNumber == 1 ) print ( \"This message prints another third of the time!\" ); else print ( \"This message prints *another* third of the time!\" );","title":"else if"},{"location":"packs/terrascript/TerraScript-Syntax/#loops","text":"Loops allow you to run a block of code repeatedly, based on a condition.","title":"Loops"},{"location":"packs/terrascript/TerraScript-Syntax/#while-loop","text":"The simplest loop is the While Loop. A while loop takes a single boolean expression, called a conditional expression, in its declaration. The block declared with the while loop will be run if the condition is true, then will continue to run until the condition is false. Examples: while ( true ) { // Since the condition is always true, the block will run infinitely. You generally want to avoid situations like this. print ( \"this runs forever!\" ); } The loop in this example runs forever, which is generally undesirable. num aNumber = 0 ; while ( number < 5 ) { // This will run the block until aNumber is NOT less than 5 (until A is greater than or equal to 5). print ( \"Number: \" + aNumber ); aNumber = aNumber + 1 ; // Add one to aNumber each time the loop runs. } This loop will run 5 times. The console output would be: Number: 0 Number: 1 Number: 2 Number: 3 Number: 4","title":"While Loop"},{"location":"packs/terrascript/TerraScript-Syntax/#for-loop","text":"The For Loop is similar to a while loop, but with 3 expressions in its declaration. Example: for ( num x = 0 ; x < 5 ; x = x + 1 ) { print ( \"Number: \" + aNumber ); } This loop does the same thing as the while loop above; it prints numbers from 0-4. It can be read as \"declare a variable called X, loop as long as x is less than 5, add 1 to x evey time.\"","title":"For Loop"},{"location":"packs/terrascript/TerraScript-Syntax/#for-loop-expressions","text":"","title":"For Loop Expressions:"},{"location":"packs/terrascript/TerraScript-Syntax/#initializer","text":"The first expression in the for loop is called the initializer. Usually this is a variable declaration. In the case of a variable declaration initializer, that variable is available only within the scope of the loop. An example is num x = 0 in the above example, which declares a number variable with identifier x that may be referenced in the loop's scope.","title":"Initializer"},{"location":"packs/terrascript/TerraScript-Syntax/#conditional","text":"The second expression in the for loop is called the conditional. It is identical to the conditional in the while loop; the loop will run so long as it is true, once it is false the loop will stop. Usually, if a variable was declared in the initializer, the conditional checks a comparison of the variable. In the example above, the conditional checks that x is less than 5.","title":"Conditional"},{"location":"packs/terrascript/TerraScript-Syntax/#incrementer","text":"The third statement in the loop is called the incrementer. The incrementer is run at the end of every loop iteration, after the entire block is executed, before the next conditional check is made. Usually the incrementer is used to increment a variable. In the example above, the incrementer adds 1 to x every iteration.","title":"Incrementer"},{"location":"packs/terrascript/TerraScript-Syntax/#flow-control","text":"TerraScript includes 4 Flow Control keywords:","title":"Flow Control"},{"location":"packs/terrascript/TerraScript-Syntax/#return","text":"The return keyword immediately halts execution of the script with \"passing\" exit status. It may be used in the base block, or in loops. Example: print ( \"This will be printed!\" ); return ; // Halt execution here. print ( \"This will never be printed!\" ); The above example exits with passing status after printing the first message. The second message will never be printed.","title":"return"},{"location":"packs/terrascript/TerraScript-Syntax/#fail","text":"The fail keyword immediately halts execution of the script with a \"failure\" exit status. It may be used in the base block, or in loops. Example: print ( \"This will be printed!\" ); fail ; // Halt execution here. print ( \"This will never be printed!\" ); The above example exits with failing status after printing the first message. The second message will never be printed. It is important to remember that both return and fail cascade, meaning that if they are used in loops they will immediately exit all parent loops and halt the script.","title":"fail"},{"location":"packs/terrascript/TerraScript-Syntax/#break","text":"The break keyword immediately halts the execution of a loop. It will immediately exit the loop, resuming execution after the loop. Since it is a loop control keyword, it may only be used in loops. Example: num aNumber = 0 ; while ( true ) { // This loop would normally be infinite. if ( aNumber > 5 ) break ; // Halt the loop if aNumber is greater than 5 print ( \"Number:\" + aNumber ); aNumber = aNumber + 1 ; } The following loop would execute until aNumber is greater than 5, then it would halt and resume execution of the rest of the script.","title":"break"},{"location":"packs/terrascript/TerraScript-Syntax/#continue","text":"The continue keyword immediately halts the current iteration of a loop. It will stop the current exexution, and go to the head of the loop, then continue the loop (if the conditional is met). Example: num aNumber = 0 ; while ( aNumber <= 5 ) { // This loop would normally be infinite. aNumber = aNumber + 1 ; print ( \"Number:\" + aNumber ); if ( aNumber > 2 ) continue ; // Go back to top if number is greater than 2 print ( \"Less than 2\" ); } The following loop would execute until aNumber is greater than 5, and prints \"Less than 2\" every time it is less than 2.","title":"continue"},{"location":"user/commands/","text":"Commands \u00b6 [//]: # TODO","title":"User Docs"},{"location":"user/commands/#commands","text":"[//]: # TODO","title":"Commands"},{"location":"user/community-addons/","text":"Community Addons \u00b6 This page contains a list of community driven addons that have been developed for Terra. Including your own addons To add your addon to this list, submit a PR to the Wiki Repository . Requirements: Addon must be free and open-source. Paid/closed-source addons will be removed from this list. Addon must not be malicious. When putting your addon on this page, include: A short description of what your addon does. A list of platforms your addon will run on. A link to your addon's source code, and (optionally) a link to get builds from. Community Addons \u00b6 MythicMobs Addon \u00b6 Adds a mythicMob function to TerraScript to spawn entities using the mythicmobs api. Platforms: Bukkit Only Spigot Page | Source Code Lootin Addon \u00b6 Adds Lootin chests support to terra structures more info about lootin can be found here Platforms: Bukkit Only Spigot Page | Source Code Fractal Trees Addon \u00b6 Adds legacy BetterEnd fractal trees to Terra. Platforms: All Source Code Warning As this addon uses a lot of internal server code, it may be unstable and will take longer to update to newer Minecraft versions. NMSAddon \u00b6 Uses internal server code to bypass some limitations of the API, allowing functionality from other platforms on Spigot/Paper. Platforms: Bukkit Only Spigot Page | Source Code NMS Addon ( Incomplete ) \u00b6 Uses internal Minecraft server code on Bukkit to get around the limitations of the Bukkit worldgen API. Platforms: Bukkit Only Source Code ItemsAdder Addon \u00b6 Adds a itemsAdderBlock function to TerraScript. Allows for the use of ItemsAdder blocks in TerraScript. Platforms: Bukkit Only Source Code","title":"Community Addons"},{"location":"user/community-addons/#community-addons","text":"This page contains a list of community driven addons that have been developed for Terra. Including your own addons To add your addon to this list, submit a PR to the Wiki Repository . Requirements: Addon must be free and open-source. Paid/closed-source addons will be removed from this list. Addon must not be malicious. When putting your addon on this page, include: A short description of what your addon does. A list of platforms your addon will run on. A link to your addon's source code, and (optionally) a link to get builds from.","title":"Community Addons"},{"location":"user/community-addons/#community-addons_1","text":"","title":"Community Addons"},{"location":"user/community-addons/#mythicmobs-addon","text":"Adds a mythicMob function to TerraScript to spawn entities using the mythicmobs api. Platforms: Bukkit Only Spigot Page | Source Code","title":"MythicMobs Addon"},{"location":"user/community-addons/#lootin-addon","text":"Adds Lootin chests support to terra structures more info about lootin can be found here Platforms: Bukkit Only Spigot Page | Source Code","title":"Lootin Addon"},{"location":"user/community-addons/#fractal-trees-addon","text":"Adds legacy BetterEnd fractal trees to Terra. Platforms: All Source Code Warning As this addon uses a lot of internal server code, it may be unstable and will take longer to update to newer Minecraft versions.","title":"Fractal Trees Addon"},{"location":"user/community-addons/#nmsaddon","text":"Uses internal server code to bypass some limitations of the API, allowing functionality from other platforms on Spigot/Paper. Platforms: Bukkit Only Spigot Page | Source Code","title":"NMSAddon"},{"location":"user/community-addons/#nms-addon-incomplete","text":"Uses internal Minecraft server code on Bukkit to get around the limitations of the Bukkit worldgen API. Platforms: Bukkit Only Source Code","title":"NMS Addon (Incomplete)"},{"location":"user/community-addons/#itemsadder-addon","text":"Adds a itemsAdderBlock function to TerraScript. Allows for the use of ItemsAdder blocks in TerraScript. Platforms: Bukkit Only Source Code","title":"ItemsAdder Addon"},{"location":"user/community-packs/","text":"Community Packs \u00b6 Full Packs \u00b6 The following packs are intended as standalone configurations. Default Config \u00b6 The default configuration that comes packaged with Terra. Property Value Author dfsek Download GitHub Releases Source GitHub Default Nether \u00b6 Danger THIS PACK IS EARLY IN DEVELOPMENT AND SHOULD NOT BE USED IN PRODUCTION The default nether configuration that comes packaged with Terra. Property Value Author dfsek Download GitHub Releases Source GitHub BetterEnd \u00b6 Danger THIS PACK IS EARLY IN DEVELOPMENT AND SHOULD NOT BE USED IN PRODUCTION ! An End based Terra pack intended to replace the Spigot plugin BetterEnd . Property Value Author dfsek Source GitHub Creative Lands \u00b6 A pack which adds biomes alongside Terra's Default biomes, with some modifications. Includes many large structures and schematics which would not be suitable for weaker computers or servers. Property Value Author Crysillion Source GitHub Partial Packs \u00b6 The following packs are intended to provide a small handful of content such as a few biomes, collections of structures, and or other miscellaneous configs. Potential applications of partial packs may include: Merging content such as biomes and structures into other packs. Using the pack generation as a canvas for building. Generating themed event worlds. These packs may not contain enough content to warrant standalone use, and may require some knowledge of Terra configurations for applications like merging into other packs. Celestial Suite - MoonBasic \u00b6 A simple pack for generating moon terrain. Property Value Author Astrash Terra Version 5.1.3 Source GitHub Screenshots Valantis Terra Config \u00b6 Warning This pack is not survival friendly. Contains a small selection of tropical themed biomes. Property Value Author Valantis Terra Version 4.0.0 Source GitHub Screenshots Santopia \u00b6 A small pack showcasing a few simple, real world inspired biomes. Property Value Author Sancires Terra Version 5.3.3, 5.4.1 Source GitHub Development Packs \u00b6 The following packs are intended for assisting in pack development, and are not for use in production environments. Template Pack \u00b6 A simple config pack intended to serve as the basis for pack development, complete with annotations explaining various aspects of Terra configurations. Property Value Author Astrash Terra Version 4.3.0 Source GitHub Image Example Pack \u00b6 An example config pack intended to showcase the use of image noise samplers in both biome distribution, and noise equations. Property Value Author Astrash Terra Version 5.1.3 Source GitHub Screenshots CaveTest \u00b6 An experimental pack centered around noise carvers. Intended for demonstration purposes, but could be adapted to be useable for regular gameplay. Property Value Author Astrash Terra Version 5.1.3 Source GitHub Screenshots","title":"Community Packs"},{"location":"user/community-packs/#community-packs","text":"","title":"Community Packs"},{"location":"user/community-packs/#full-packs","text":"The following packs are intended as standalone configurations.","title":"Full Packs"},{"location":"user/community-packs/#default-config","text":"The default configuration that comes packaged with Terra. Property Value Author dfsek Download GitHub Releases Source GitHub","title":"Default Config"},{"location":"user/community-packs/#default-nether","text":"Danger THIS PACK IS EARLY IN DEVELOPMENT AND SHOULD NOT BE USED IN PRODUCTION The default nether configuration that comes packaged with Terra. Property Value Author dfsek Download GitHub Releases Source GitHub","title":"Default Nether"},{"location":"user/community-packs/#betterend","text":"Danger THIS PACK IS EARLY IN DEVELOPMENT AND SHOULD NOT BE USED IN PRODUCTION ! An End based Terra pack intended to replace the Spigot plugin BetterEnd . Property Value Author dfsek Source GitHub","title":"BetterEnd"},{"location":"user/community-packs/#creative-lands","text":"A pack which adds biomes alongside Terra's Default biomes, with some modifications. Includes many large structures and schematics which would not be suitable for weaker computers or servers. Property Value Author Crysillion Source GitHub","title":"Creative Lands"},{"location":"user/community-packs/#partial-packs","text":"The following packs are intended to provide a small handful of content such as a few biomes, collections of structures, and or other miscellaneous configs. Potential applications of partial packs may include: Merging content such as biomes and structures into other packs. Using the pack generation as a canvas for building. Generating themed event worlds. These packs may not contain enough content to warrant standalone use, and may require some knowledge of Terra configurations for applications like merging into other packs.","title":"Partial Packs"},{"location":"user/community-packs/#celestial-suite-moonbasic","text":"A simple pack for generating moon terrain. Property Value Author Astrash Terra Version 5.1.3 Source GitHub Screenshots","title":"Celestial Suite - MoonBasic"},{"location":"user/community-packs/#valantis-terra-config","text":"Warning This pack is not survival friendly. Contains a small selection of tropical themed biomes. Property Value Author Valantis Terra Version 4.0.0 Source GitHub Screenshots","title":"Valantis Terra Config"},{"location":"user/community-packs/#santopia","text":"A small pack showcasing a few simple, real world inspired biomes. Property Value Author Sancires Terra Version 5.3.3, 5.4.1 Source GitHub","title":"Santopia"},{"location":"user/community-packs/#development-packs","text":"The following packs are intended for assisting in pack development, and are not for use in production environments.","title":"Development Packs"},{"location":"user/community-packs/#template-pack","text":"A simple config pack intended to serve as the basis for pack development, complete with annotations explaining various aspects of Terra configurations. Property Value Author Astrash Terra Version 4.3.0 Source GitHub","title":"Template Pack"},{"location":"user/community-packs/#image-example-pack","text":"An example config pack intended to showcase the use of image noise samplers in both biome distribution, and noise equations. Property Value Author Astrash Terra Version 5.1.3 Source GitHub Screenshots","title":"Image Example Pack"},{"location":"user/community-packs/#cavetest","text":"An experimental pack centered around noise carvers. Intended for demonstration purposes, but could be adapted to be useable for regular gameplay. Property Value Author Astrash Terra Version 5.1.3 Source GitHub Screenshots","title":"CaveTest"}]}